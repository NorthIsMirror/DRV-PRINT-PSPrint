diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/build.cmd src\osdd\pscript\psprint/build.cmd
--- src\osdd\pscript\post32/build.cmd	Thu Jan  1 00:00:00 1970
+++ src\osdd\pscript\psprint/build.cmd	Sun May 25 22:01:14 2014
@@ -0,0 +1,25 @@
+/* build.cmd */
+arg _opt _nlv
+if _opt == 'DEBUG' then do
+    target = 'dbgos2c'
+end
+else do
+    _opt = 'RETAIL'
+    target = 'retos2c'
+end
+if _nlv == '' then
+    _nlv = 'EN'
+timestamp = Left( Date('S') Time('N'), 17 )
+mydir = Directory()
+parse upper var mydir ddktop '\PRINT\SRC\OSDD' .
+objdir = ddktop'\PRINT\OBJ\OS2C\'_opt'\OSDD\PSCRIPT\PSPRINT'
+deffile = Stream( objdir'\'_nlv'\PSPRINT.DEF', 'c', 'query exists')
+if deffile <> '' then
+    '@del' deffile
+call setlocal
+/* '@set OPENTYPE_SUPPORT=1' */
+'@set _BLDSTAMP='timestamp
+'nmake' target '2>&1 |tee build.log'
+ret = rc
+call endlocal
+return ret
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/charstr2.c src\osdd\pscript\psprint/charstr2.c
--- src\osdd\pscript\post32/charstr2.c	Tue Nov 11 18:09:56 2003
+++ src\osdd\pscript\psprint/charstr2.c	Fri Aug 30 22:39:08 2013
@@ -115,7 +115,6 @@
 
 #include "inc\package.h"               //@EXTFONT
 
-
 extern BOOL    RemapCodePage(PDDC,SHORT,SHORT,PSZ);
 extern PVOID   LoadFile(PDV, PSZ); /* download.c  */
 extern SHORT   RealizeCharKind(PDDC ,PCH, LONG);                          //@DBCS
@@ -123,6 +122,9 @@
 extern BOOL    IsDBCSFont(PDDC);                                          //@DBCS
 extern HMODULE pscript_module;
 extern VOID    ChangeDBCSFont(PDDC, SHORT);
+extern LONG    IsOFMFile( PSZ pszName );        // ALT_CUPS
+extern LONG    IsTTFFile( PSZ pszName );        // ALT_CUPS
+extern PFONTDEF ConvertTTFtoPFM( PDV pdv, PSZ pszFilename );    // ALT_CUPS
 
 #define  NO_CODEPAGE   65400
 
@@ -439,15 +441,57 @@
       else
           DosFreeResource( pResource );
     }
+
+// ALT_CUPS
+    /*
+    ** Check if it's a TrueType font file
+    */
+    else if ( pFnt->pszOFM && *(pFnt->pszOFM) && IsTTFFile( pFnt->pszOFM ) > 0 )
+    {
+       pFontDef = ConvertTTFtoPFM( pddc->pdv, pFnt->pszOFM );
+       if ( !pFontDef )
+        return NULL;
+    }
+#ifdef OPENTYPE_SUPPORT
+    else if ( pFnt->pszOFM && *(pFnt->pszOFM) && IsOTFFile( pFnt->pszOFM ) > 0 )
+    {
+       pFontDef = ConvertOTFtoPFM( pddc->pdv, pFnt->pszOFM );
+       if ( !pFontDef )
+        return NULL;
+    }
+#endif
+    /* This conditional breaks device font detection, removed */
+    /* else if ( pFnt->pszOFM && *(pFnt->pszOFM) && IsOFMFile( pFnt->pszOFM ) > 0 ) */
+    /*
+    ** Could be a Type 1 font file, but the following also catches device fonts.
+    */
+// ALT_CUPS
     else
     {
+/* // ALT_CUPS
+** // This was intended to try and prevent crashes if the device fonts are
+** // undefined.  (Unfortunately, it just moved the crash somewhere else.)
+** // The eventual fix was to avoid the problem entirely by making sure PIN
+** // doesn't generate bogus font offset values in the PAK file to begin with.
+**    // DEBUG: "[prda_LoadFontResource] Fallthrough (OFM or device font): requested index %u\n", usIndex
+**    if ( !pFnt )
+**        return NULL;
+**    if ( !pFnt->pszOFM )
+**        return NULL;
+**    if ( *(pFnt->pszOFM) == 0 )
+**        return NULL;
+**    // DEBUG: "[prda_LoadFontResource] Loading file %s\n", pFnt->pszOFM );
+** // ALT_CUPS/
+*/
+
       /* @2.195445 */
       if ( ! ( pResource = LoadFile( pddc->pdv, pFnt->pszOFM) ) )
       {
         return NULL;
       }
 
-      /*      ** If using OFMs must convert to PFM format
+      /*
+      ** If using OFMs must convert to PFM format
       */
       pFontDef = ConvertOFMtoPFM( pddc->pdv, pResource );
 
@@ -458,7 +502,11 @@
       ** Remove second parameter (PDV).  Not needed here.
       */
       GplMemoryFree( pResource );
+
     }
+    // ALT_CUPS - removed (see above)
+    /* else return NULL;           // unknown, give up  */
+    // ALT_CUPS
 
     /*
     ** Try and put font in cache
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/config.c src\osdd\pscript\psprint/config.c
--- src\osdd\pscript\post32/config.c	Tue Nov 11 18:10:02 2003
+++ src\osdd\pscript\psprint/config.c	Mon Aug 19 10:58:32 2013
@@ -149,7 +149,7 @@
 CHAR szFontMemPS2[] = " = ) show \nvmstatus exch sub dup s cvs show "
                       "72 550 moveto (";
                     /*Suggested fonts*/
-CHAR szFontMemPS3[] = ": ) show \n100000 sub 80000 div round cvi s cvs show "
+CHAR szFontMemPS3[] = ": ) show \n100000 sub 500000 div round cvi s cvs show "
                       "showpage pop restore \x04";
 
 /*
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/devblock.c src\osdd\pscript\psprint/devblock.c
--- src\osdd\pscript\post32/devblock.c	Tue Nov 11 18:10:04 2003
+++ src\osdd\pscript\psprint/devblock.c	Tue Jan 20 23:55:50 2015
@@ -737,7 +737,7 @@
   HMODULE    hmodule;                  /* Scratch variable to get driver
                                           module handle                     */
   PSIGNATURE pSignature;               /* Pointer to signature              */
-  SHORT      i, j;
+  SHORT      i, j;          // XXX ALT 20140526   SHORT -> USHORT
   SHORT      iCntFiles;                /* Stack var                         */
   SHORT      usDirSize;
   PDRENTRY   pdrTable;                 /* pointer to printer segments
@@ -3478,7 +3478,8 @@
 
       SaveINIGroupData( (PBYTE) pdv->pUISelectList, NULL );
 
-      pCNFData->jobProperties.fIsColorDevice = TRUE;
+// ALT 20150120
+//      pCNFData->jobProperties.fIsColorDevice = TRUE;
     }
   }
 }
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/dlg.c src\osdd\pscript\psprint/dlg.c
--- src\osdd\pscript\post32/dlg.c	Tue Nov 11 18:10:08 2003
+++ src\osdd\pscript\psprint/dlg.c	Tue Jan 20 22:23:42 2015
@@ -1490,6 +1490,7 @@
          switch( ulCtrlID )
          {
          case JPE_COLOR_LIST:
+#if 0       // ALT 20141204
               if (lIndex == 0)
               {
                 iIndex = ICON_COLOR;
@@ -1498,6 +1499,13 @@
               {
                 iIndex = ICON_MONOCHROME;
               }
+#else
+              iIndex =
+                (SHORT) WinSendDlgItemMsg( WinQueryWindow( hCtrl, QW_PARENT ),
+                                           JPE_COLORCHECK, BM_QUERYCHECK,
+                                           (MPARAM) 0, (MPARAM) 0 ) ?
+                        ICON_MONOCHROME : ICON_COLOR;
+#endif      // ALT 20141204
               sItemIndex = JPSB_MONOCHROME;
               break;
          }
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/download.c src\osdd\pscript\psprint/download.c
--- src\osdd\pscript\post32/download.c	Tue Nov 11 18:10:08 2003
+++ src\osdd\pscript\psprint/download.c	Sun Sep  1 00:01:10 2013
@@ -37,6 +37,7 @@
  *
  *      extern VOID   WriteChannel(PDDC,PBYTE,SHORT);
  *      extern BOOL   szIsEqual(PSZ,PSZ);
+ *      (various FNTLIB routines)
  *
 */
 #pragma pack(1)
@@ -54,6 +55,7 @@
 
 #include <string.h>
 #include <stdlib.h>
+#include <stdio.h>
 #include <memory.h>
 #include <os2.h>
 //#include <bseerr.h>
@@ -69,6 +71,7 @@
 #define  INCL_GENPLIB_MEMORY
 #define  INCL_GENPLIB_THREAD
 #define  INCL_GENPLIB_LAYOUT
+#define  INCL_GENPLIB_COMPRESS
 #include <genplib.h>
 #include "inc\softfont.h"
 #include "inc\prdtypet.h"           /* only so we can include the next one */
@@ -79,12 +82,41 @@
 #include "inc\utl.h"
 #include "inc\pspagtun.h"           /* V2.174057  Page Tuning */
 
+// ALT_PSPRINT
+#define OS2D2_H
+#include "fntlib\inc\fntlib.h"
+#include "fntlib\inc\ttf.h"
+#include "fntlib\inc\afm2bin.h"
+#include "fntlib\inc\mapping.h"
+
+extern void appendBaseName(PSZ tar, PSZ src);
+extern void DeleteFile(PSZ Filename);
+extern BOOL FixName(PSZ input, PSZ type, PSZ output);
+// ALT_PSPRINT
+
 /*
 **  Constants
 */
 #define RWBUFSIZE 500
 #define ARBITRARY_CODEPAGE 65400    
 
+// ALT_PSPRINT
+#ifndef STR_SIZE
+#define STR_SIZE  256
+#endif
+
+/* Maximum size of TTF files to allow embedding in a print job */
+#define MAX_TTF_SIZE_SAFE     0x80000       // maximum if vmem size is unknown
+#define MAX_TTF_SIZE_ABSOLUTE 0x200000      // absolute maximum
+
+#ifdef OPENTYPE_SUPPORT
+/* OpenType font type flags */
+#define OTF_INVALID         0               // not a valid TT/OT font
+#define OTF_TYPE_TTF        1               // TrueType (or OpenType/TT) font
+#define OTF_TYPE_CFF        2               // OpenType/PS (CFF) font
+#endif
+// ALT_PSPRINT
+
 /*
 **  External variables
 */
@@ -96,9 +128,16 @@
 
 //extern VOID   WriteChannel(PDDC,PBYTE,SHORT); /* utlchnl.c */
 extern BOOL   _System szIsEqual(PSZ,PSZ);
+// ALT_PSPRINT
+extern BOOL PSprocessTags(FILE *ifl, TTFDATA *pttfdt, FONTMETRICS *pFM, AFMData *pAD);
+extern BOOL PSgetCMapData(FILE *fl, USHORT **pCMap, BOOL nofmt0);
+extern void PSfillTTFheader(PSTTFHDR *pth, TTFDATA *pttfdt);
+extern BOOL TTFPopulatePFA(FILE *ifl, TTFDATA *pttfdt, AFMData *pAD);
 
 /*
+** Already defined in FNTLIB headers
 */
+#ifdef DDKBLD                   // ALT_PSPRINT
 SHORT iWeightFactor[] =
 {
   64,             /* a */
@@ -128,6 +167,7 @@
   18,             /* y */
    2              /* z */
 };
+#endif                      // ALT_PSPRINT
 
 extern PVOID pProcessHeap;
 extern GLOBALDATA globals;
@@ -138,6 +178,18 @@
 
 PSZ   SeekChar(CHAR,PSZ);
 VOID  SendPFB( PDDC,  HFILE );                       
+// ALT_PSPRINT
+VOID     SendPFA( PDDC pddc,  HFILE hPFA );
+LONG     IsTTFFile( PSZ pszName );
+VOID     FillTTFont( PDV pdv, PFNT pFnt, PSZ pszKeyName );
+BOOL     GetTTFNames( PSZ pszFile, PSZ pszName, PSZ pszPSName );
+PFONTDEF ConvertTTFtoPFM( PDV pdv, PSZ pszFilename );
+#ifdef OPENTYPE_SUPPORT
+LONG     IsOTFFile( PSZ pszName );
+CHAR     GetOTFInfo( PSZ pszFile, PSZ pszName, PSZ pszPSName );
+BOOL     CreateCFFFontSet( PFONT_PROFILE prFontProfile );
+#endif
+// ALT_PSPRINT
 
 /*
 */
@@ -289,10 +341,119 @@
   LONG   lRequest;
   ULONG  ulNewMaxFH;
   INT    iRetry = 1;
+// ALT_PSPRINT
+  INT    len;
+  PSZ    pExt = NULL;
+  USHORT fsFontType;
+  PSZ    pszPSFont = pszPFB;
+  PSZ    tempdir;
+  FONT_PROFILE fntprf = {0};
+
+#define FONT_TYPE_PS  0       // native PS font (Type 1/3)
+#define FONT_TYPE_TT  1       // TrueType font (a.k.a. Type 42)
+#define FONT_TYPE_OT  2       // OpenType/CFF (a.k.a. Type 2)
+
+  fsFontType = FONT_TYPE_PS;
+
+//  PrintChannel( pddc ,(PSZ) "%% Downloading font: ");
+//  PrintChannel( pddc , pszPFB );
+
+  if ( IsTTFFile( pszPFB ) > 0 )
+  {
+//     PrintChannel( pddc , " (TTF)");
+     fsFontType = FONT_TYPE_TT;
+
+     // find a suitable working directory to generate the Type42 data file
+     tempdir = getenv("TMP");
+     if ( tempdir == NULL )
+        tempdir = getenv("TEMP");
+     if ( tempdir == NULL )
+        sprintf( fntprf.szPrinterOutput, "%c:\\", (CHAR)globals.BootDrive );
+     else {
+        strncpy( fntprf.szPrinterOutput, tempdir, CCHMAXPATH-1 );
+        len = strlen( fntprf.szPrinterOutput );
+        if ( fntprf.szPrinterOutput[len] != '\\')
+            strncat( fntprf.szPrinterOutput, "\\", CCHMAXPATH-1 );
+     }
+
+     fntprf.ulSize = sizeof( FONT_PROFILE );
+     fntprf.usVersion = 2;      // not sure this is used, but set it anyway
+     strncpy( fntprf.szFontBinary, pszPFB, CCHMAXPATH-1 );
+
+     // now convert the TTF into a Type42 PostScript file
+     if ( ! FntLibCreateOutputPS( &fntprf )) {
+        fntprf.szPrinterOutput[ 0 ] = '\0';
+//      PrintChannel( pddc , " --> Failed to generate Type42 font!");
+        // don't need to return here, that'll happen below when DosOpen fails
+     }
+     else {
+        pExt = strrchr( fntprf.szPrinterOutput, '.');
+        len = strlen( fntprf.szPrinterOutput );
+
+        // Add the .pfa extension back onto the file if necessary
+        if (( pExt == NULL || ( pExt && stricmp( pExt, ".pfa") != 0 )) &&
+            (( len + 4 ) < sizeof( fntprf.szPrinterOutput )))
+        {
+            fntprf.szPrinterOutput[ len++ ] = '.';
+            fntprf.szPrinterOutput[ len++ ] = 'p';
+            fntprf.szPrinterOutput[ len++ ] = 'f';
+            fntprf.szPrinterOutput[ len++ ] = 'a';
+        }
+        pszPSFont = fntprf.szPrinterOutput;
+        // PrintChannel( pddc , " --> %s", pszPSFont );
+     }
+  }
+#ifdef OPENTYPE_SUPPORT
+  else if ( IsOTFFile( pszPFB ) > 0 )
+  {
+     fsFontType = FONT_TYPE_OT;
+
+     // find a suitable working directory to generate the converted CFF resource
+     tempdir = getenv("TMP");
+     if ( tempdir == NULL )
+        tempdir = getenv("TEMP");
+     if ( tempdir == NULL )
+        sprintf( fntprf.szPrinterOutput, "%c:\\", (CHAR)globals.BootDrive );
+     else {
+        strncpy( fntprf.szPrinterOutput, tempdir, CCHMAXPATH-1 );
+        len = strlen( fntprf.szPrinterOutput );
+        if ( fntprf.szPrinterOutput[len] != '\\')
+            strncat( fntprf.szPrinterOutput, "\\", CCHMAXPATH-1 );
+     }
+
+     fntprf.ulSize = sizeof( FONT_PROFILE );
+     fntprf.usVersion = 2;      // not sure this is used, but set it anyway
+     strncpy( fntprf.szFontBinary, pszPFB, CCHMAXPATH-1 );
+
+     // now extract the CFF table from the OTF and generate a FontSet resource
+     if ( ! CreateCFFFontSet( &fntprf )) {
+        fntprf.szPrinterOutput[ 0 ] = '\0';
+        // don't need to return here, that'll happen below when DosOpen fails
+     }
+     else {
+        pExt = strrchr( fntprf.szPrinterOutput, '.');
+        len = strlen( fntprf.szPrinterOutput );
+
+        // Add the .pfa extension back onto the file if necessary
+        if (( pExt == NULL || ( pExt && stricmp( pExt, ".pfa") != 0 )) &&
+            (( len + 4 ) < sizeof( fntprf.szPrinterOutput )))
+        {
+            fntprf.szPrinterOutput[ len++ ] = '.';
+            fntprf.szPrinterOutput[ len++ ] = 'p';
+            fntprf.szPrinterOutput[ len++ ] = 'f';
+            fntprf.szPrinterOutput[ len++ ] = 'a';
+        }
+        pszPSFont = fntprf.szPrinterOutput;
+     }
+  }
+#endif
+
+//  PrintChannel( pddc , "\n");
+// ALT_PSPRINT
 
   do  /* @2.195445 */
   {
-    rc = DosOpen( pszPFB, (PHFILE) &hPFA, &usAct, 0L, 0, FILE_OPEN,
+    rc = DosOpen( pszPSFont, (PHFILE) &hPFA, &usAct, 0L, 0, FILE_OPEN,  // ALT_PSPRINT
                   OPEN_READ_FLAGS, 0L );
     if ( rc == ERROR_TOO_MANY_OPEN_FILES )
     {
@@ -313,20 +474,31 @@
     GplBookletSetOutput( pddc->pdv->hThread, BOOKLET_OUTPUT_FONTS );
   }
   
-
-  
+// ALT_PSPRINT
+  // PrintChannel( pddc , "%% File opened, writing to channel.\n");
+  if (( fsFontType == FONT_TYPE_TT ) || ( fsFontType == FONT_TYPE_OT ))
+    SendPFA( pddc, hPFA );
+  else
+// ALT_PSPRINT
   SendPFB( pddc, hPFA );
 
-  
   if ( ! GplBookletCheckThread( pddc->pdv->hThread, BOOKLET_THREAD_DIRECT ) )
   {
     FlushChannel( pddc );
     GplBookletResetOutput( pddc->pdv->hThread );
   }
   
-
   DosClose( hPFA );
 
+// ALT_PSPRINT
+  if ( fntprf.szPrinterOutput[ 0 ] ) {
+     // Lose the .pfa extension because FNTLIB doesn't expect it
+     pExt = strrchr( fntprf.szPrinterOutput, '.');
+     if ( pExt != NULL ) *pExt = '\0';
+     FntLibDeleteOutputPS( &fntprf );
+  }
+// ALT_PSPRINT
+
   return ;
 }
 
@@ -742,21 +914,23 @@
 
   strcpy( pFnt->pszPFB, pFontFileName );
 
+//if (g_debuglog) fprintf(g_debuglog, "Added Type 1 font \"%s\": %s\n", pFnt->pszFontName, pFnt->pszOFM );
+
   GplMemoryFree( pOFM ); /* Free the OFM data */
 
   return;
 }
 
 /*
-** SFReadOFMs either counts the number of OFM fonts in system -or-
+** SFReadOFMs either counts the number of OFM/TTF/OTF fonts in system -or-
 ** fills in the array of FNT structs with the requested info
 */
 /*****************************************************************************\
 **
 ** SFReadOFMs
 **
-** Acts as comined SFQueryFonts and FillSFonts depending on arguments
-** If cFnt is 0 then we return a count else we get a list of OFM files
+** Acts as combined SFQueryFonts and FillSFonts depending on arguments
+** If cFnt is 0 then we return a count else we get a list of outline font files
 ** from .ini and load the FNT struct from them.
 **
 \*****************************************************************************/
@@ -784,6 +958,30 @@
         pFnt++;   /* go to next struct */
       }
     }
+// ALT_PSPRINT
+    else if (( lLength = IsTTFFile( pszFontFiles )) > 0 )
+    {
+      lCount++;
+      if ( bFillPFnt )
+      {
+        FillTTFont( pdv, pFnt, pszFontFiles ); /* Call with key name */
+
+        pFnt++;   /* go to next struct */
+      }
+    }
+#ifdef OPENTYPE_SUPPORT
+    else if (( lLength = IsOTFFile( pszFontFiles )) > 0 )
+    {
+      lCount++;
+      if ( bFillPFnt )
+      {
+        FillTTFont( pdv, pFnt, pszFontFiles ); /* Call with key name */
+
+        pFnt++;   /* go to next struct */
+      }
+    }
+#endif
+// ALT_PSPRINT
     else
     {
       lLength *= -1;
@@ -860,6 +1058,7 @@
     pFNT = globals.FontData.pFNTList;
     for ( i = 0; i < globals.FontData.lCount; i++ )
     {
+      if ( pFNT && pFNT->pszFullName )              // ALT_PSPRINT
       GplMemoryFree( pFNT->pszFullName );
       pFNT++;
     }
@@ -914,6 +1113,13 @@
   LONG  lCount;
   PFNT  pGlobalFnt;
   INT   iVarSize;
+// ALT_PSPRINT
+  LONG  lFontLimit;         /* maximum size of an embeddable TTF/OTF font */
+  BOOL  fIsTTF;             /* font has TTF or OTF extension */
+  BOOL  fIsOTF;             /* font has OTF extension */
+  BOOL  fCanEmbed;          /* font is embeddable */
+  FILESTATUS3 fs3;
+// ALT_PSPRINT
 
   //Lock (Font)globals before this call
 
@@ -928,16 +1134,64 @@
     pStartFNT = pFnt - uHWFonts;
   }
 
+// ALT_PSPRINT
+  /*
+  ** Try and set a practical maximum size for embedded TT fonts.  Currently,
+  ** we use either half the minimum FreeVM size (if any is defined), or 2 MiB,
+  ** whichever is less.  (We don't bother with this for Type 1 fonts, partly
+  ** because they're generally much smaller, and partly because IBM didn't
+  ** seem to think it was necessary...)
+  */
+  lFontLimit = ( pdv->pdesPPD->desItems.lFreeVM > 0 ) ?
+               min( pdv->pdesPPD->desItems.lFreeVM / 2, MAX_TTF_SIZE_ABSOLUTE ) :
+               MAX_TTF_SIZE_SAFE;   // use max 512KB if no FreeVM is defined
+// ALT_PSPRINT
+
   while ( cFnt && lCount )
   {
     *pFnt = *pGlobalFnt;    /* Copy the FNT struct */
 
+// ALT_PSPRINT
+#ifdef OPENTYPE_SUPPORT
+    fIsOTF = ( pGlobalFnt->pszFullName &&
+              ( IsOTFFile( pFnt->pszPFB ) > 0 )) ? TRUE : FALSE;
+#else
+    /* OTF support is not enabled yet */
+    fIsOTF = FALSE;
+#endif
+    fIsTTF = ( fIsOTF || ( pGlobalFnt->pszFullName &&
+              ( IsTTFFile( pFnt->pszPFB ) > 0 ))) ? TRUE : FALSE;
+    if (fIsTTF &&
+        ( DosQueryPathInfo( pFnt->pszPFB, FIL_STANDARD, &fs3,
+                            sizeof( FILESTATUS3 )) != NO_ERROR ))
+        fs3.cbFile = 0;
+
+    /*
+    ** If this is a TrueType or OpenType font, make sure the printer can handle
+    ** them.  Also, skip any font that's too large (at least until we can
+    ** implement incremental downloading, if that's possible).
+    */
+    fCanEmbed = ( pGlobalFnt->pszFullName &&
+                 ( !fIsTTF ||
+                   (( pdv->pdesPPD->desItems.fTTSupport == TRUE ) &&
+                    ( fs3.cbFile <= (lFontLimit? lFontLimit: MAX_TTF_SIZE_SAFE )))
+                 )
+                );
+#ifdef OPENTYPE_SUPPORT
+    /* For OTF fonts, also make sure the printer has at least PS level 3 */
+    if ( fIsOTF && pdv->pdesPPD->desItems.usLanguageLevel < 3 )
+        fCanEmbed = FALSE;
+#endif
+    if ( fCanEmbed )
+    {
+// ALT_PSPRINT
+
     /* Since only the first ptr is alloc-ed do it here */
 
     iVarSize = GplMemoryGetObjectSize( pGlobalFnt->pszFullName );
     pFnt->pszFullName = GplMemoryAlloc( pdv->pDCHeap, iVarSize );
 
-    /* Copy the variable string data over form globale memory */
+      /* Copy the variable string data over from global memory */
 
     memcpy( pFnt->pszFullName, pGlobalFnt->pszFullName, iVarSize );
 
@@ -952,15 +1206,23 @@
     /*
     ** If this is the same name as a HW font mark resource as already downloaded
     */
-//@252840 
-// if we use printer device fonts, mark the font as already downloaded so it's never downloaded. 
-// Else - we will just have to download font into printer (or realize through engine).
+  //@252840
+  // if we use printer device fonts, mark the font as already downloaded so it's never downloaded.
+  // Else - we will just have to download font into printer (or realize through engine).
     if ( pdv->pCNFData->sUsePDFonts && isHWFont( pdv, pFnt ) ) 
     {
         pFnt->usResource = -1;
 //        pFnt->bLoaded = TRUE | LOCKED; // commented out on purpose, just an idea //@252840  
     }
-
+    }
+// ALT_PSPRINT
+    else {
+       pFnt->pszFullName = NULL;
+       pFnt->pszFontName = NULL;
+       pFnt->pszOFM      = NULL;
+       pFnt->pszPFB      = NULL;
+    }
+// ALT_PSPRINT
     cFnt--;
     lCount--;
     pFnt++;
@@ -1000,6 +1262,10 @@
 
   #define GLYPHCOUNT 383
 
+/*
+g_debuglog = fopen("c:\\pscript.log", "a");
+fprintf( g_debuglog, "*** [ConvertOFMtoPFM] Opened log file.\n");
+*/
   
   // Glyph numbers can be higher than the count so must allocate to highest
   // glyph
@@ -1037,6 +1303,7 @@
   usS += (USHORT)pOFM->KerningPairsCount * sizeof( KERNPAIRS );
   usS += 32 * 2;  /* font name */
 
+//fprintf( g_debuglog, "*** [ConvertOFMtoPFM] Creating buffer.\n");
 
   /*
   ** Alocate buffer
@@ -1044,6 +1311,8 @@
   if ( (pFD = (PFONTDEF)GplMemoryAlloc( pdv->pDCHeap, usS )) == NULL )
     return ( pFD );
 
+//fprintf( g_debuglog, "*** [ConvertOFMtoPFM] Setting font data.\n");
+
   /*
   ** Fill in Font Header
   */
@@ -1075,6 +1344,8 @@
     pB++;   /* Word align */
   }
 
+//fprintf( g_debuglog, "*** [ConvertOFMtoPFM] Filling widths.\n");
+
   pFH->usCharMetricsOffset = (USHORT)(pB - (PBYTE)pFD );
 
   /*
@@ -1316,9 +1587,13 @@
   pB -= pFH->usCharMetricsOffset;
   pFH->usSectionsSize = OFFSETOF( pB );
 
+//fprintf( g_debuglog, "*** [ConvertOFMtoPFM] Closing log file.\n");
+//fclose( g_debuglog );
+
   return( pFD );
 }
 
+
 /*****************************************************************************\
 **
 ** DefaultFontCount
@@ -1470,5 +1745,1182 @@
   return pFD;
 
 }
-/*
-*/
+
+
+// ALT_PSPRINT
+/*****************************************************************************\
+**                                                                          **
+**               NEW ROUTINES SPECIFIC TO TRUETYPE SUPPORT                  **
+**                                                                          **
+\*****************************************************************************/
+
+
+/*****************************************************************************\
+**
+** IsTTFFile
+**
+** Checks supplied name to see if it ends in .ttf.  If true returns positive
+** length.  If false returns negative length.
+**
+\*****************************************************************************/
+
+LONG IsTTFFile( PSZ pszName )
+{
+  register SHORT sLength1;
+  register SHORT sLength2;
+  SHORT          sSign = -1;
+
+  sLength1 = strlen( pszName );
+
+  // Find the (last) dot if there is one
+  while ( sLength1 &&
+          pszName[sLength1-1] != '.' )
+  {
+    sLength1--;
+  }
+  if ( sLength1 )
+     pszName += (--sLength1);
+
+  /*
+  ** if there are 4 chars left and they are ".TTF" or ".TTC"
+  ** set up positive return
+  */
+  if ( (sLength2 = strlen( pszName )) == 4 )
+  {
+    if ( *(pszName+1) == 'T' &&
+         *(pszName+2) == 'T' &&
+         (*(pszName+3) == 'F') || (*(pszName+3) == 'C') )
+      sSign = 1;
+  }
+
+  return ( sLength1 + sLength2 ) * sSign;
+}
+
+/*****************************************************************************\
+**
+** GetTTFNames
+**
+** Opens the TTF file and parses out the "normal" and "PostScript" font names.
+** Relies on FNTLIB (in fact, this routine is mostly stolen from isFileTTFont).
+**
+**  PSZ pszFile    TTF filename to be parsed
+**  PSZ pszName    Buffer to receive full name of font
+**  PSZ pszPSName  Buffer to receive PostScript name of font
+**
+\*****************************************************************************/
+BOOL GetTTFNames( PSZ pszFile, PSZ pszName, PSZ pszPSName )
+{
+  FILE      *fl;
+  UCHAR     data[TTF_HEADER_SIZE];
+  USHORT    tblents;
+  USHORT    lp;
+  TBLENT    *te;
+  long      fndtags;
+
+  /* init variables */
+  fndtags = 0;
+  pszName[0] = '\0';
+  pszPSName[0] = '\0';
+
+  /* open the file */
+  fl = fopen(pszFile, "rb");
+  if (fl != NULL)
+  {
+    /* read the TTF header */
+    if (fread(data, sizeof(char), TTF_HEADER_SIZE, fl) == TTF_HEADER_SIZE)
+    {
+      /* if the version is valid */
+      if ((data[0] == 0x00) && (data[1] == 0x01) && (data[2] == 0x00) &&
+          (data[3] == 0x00))
+      {
+        /* get count of table entries */
+        tblents = ((USHORT)data[4] << 8) + (USHORT)data[5];
+
+        te = (TBLENT *)malloc(sizeof(TBLENT) * tblents);
+        if (te != (TBLENT *)NULL)
+        {
+          if (fread(te, sizeof(TBLENT), tblents, fl) == tblents)
+          {
+            for (lp = 0; lp < tblents; lp++)
+            {
+              swapTblent(&te[lp]);
+              switch(te[lp].tag)
+              {
+                case TT_NAME_TAG:
+                  getTTFName(&te[lp], fl, pszPSName, FALSE);
+                  getTTFName(&te[lp], fl, pszName,   TRUE);
+                  break;
+
+                default:
+                  break;
+              }
+              // stop searching once we've found both names
+              if ( pszName[0] && pszPSName[0] ) break;
+            }
+          }
+          free(te);
+        }
+      }
+    }
+    fclose(fl);
+  }
+
+  if ( pszName[0] && pszPSName[0] )
+     return TRUE;
+
+  return FALSE;
+}
+
+/*****************************************************************************\
+**
+** FillTTFont
+**
+\*****************************************************************************/
+
+VOID FillTTFont( PDV pdv, PFNT pFnt, PSZ pszKeyName )
+{
+  CHAR            chFontFileName[ 255 ];
+  CHAR            chFullName[ STR_SIZE ];   // user-displayable font name
+  CHAR            chFontName[ STR_SIZE ];   // PS font name for printer
+  PCHAR           pFontFileName;
+  ULONG           ulCount;
+  POFMMETRICS     pOFM;
+  PSZ             pFontName;
+  PSZ             pFullName;
+  LONG            lFileLen;
+  LONG            lTotalLen;
+  LONG            lFontLen;
+  LONG            lFullLen;
+
+  /*
+  ** Save room for drive if needed
+  */
+  pFontFileName = chFontFileName+2;
+
+  pFullName = chFullName;
+  pFontName = chFontName;
+
+  /*
+  ** Look up the actual full file name for the font file
+  */
+  if ( (ulCount = PrfQueryProfileString( HINI_PROFILE, "PM_Fonts",
+     pszKeyName, NULL, pFontFileName, (ULONG) sizeof(chFontFileName)-2)) == 0 )
+  {
+    return;
+  }
+
+  if ( *pFontFileName == '\\' )   /* no drive, put in boot drive */
+  {
+    pFontFileName--;
+    *pFontFileName = ':';
+    pFontFileName--;
+    *pFontFileName = (CHAR)globals.BootDrive;
+  }
+
+//if (g_debuglog) fprintf(g_debuglog, "Getting TTF names for \"%s\"... ", pFontFileName);
+
+  pFnt->usResource = 0;                   /* SoftFont */
+
+  /* Parse the font names out of the font file
+  */
+#ifdef OPENTYPE_SUPPORT
+  if ( GetOTFInfo( pFontFileName, pFullName, pFontName ) == OTF_INVALID )
+#else
+  if ( ! GetTTFNames( pFontFileName, pFullName, pFontName ))
+#endif
+  {
+    /*
+    ** If font file fails to parse successfully set ptrs to NULL
+    */
+//if (g_debuglog) fprintf(g_debuglog, "Failed\n");
+    pFnt->pszFullName = NULL;
+    pFnt->pszFontName = NULL;
+    return;
+  }
+//if (g_debuglog) fprintf(g_debuglog, "OK\n");
+
+  lFileLen = strlen( pFontFileName ) + 1; /* Len of font filename + null */
+
+  /*
+  ** FullName/FontName structs are OFFSETS not pointers
+  */
+  if ( strlen(pFullName) > 31 )  /* Must truncate */
+    pFullName[31] = '\0';
+
+  /*
+  ** Allocate all four strings in one operation for efficiency.
+  ** Total len of strings is 2 filenames + fontname + fullname.
+  */
+  lFontLen = strlen( pFontName ) + 1;
+  lFullLen = strlen( pFullName ) + 1;
+  lTotalLen = ( lFileLen * 2 ) + lFullLen + lFontLen;
+  if ( ! ( pFnt->pszFullName = GplMemoryAlloc( globals.hMCB, lTotalLen )))
+    return;
+
+  strcpy( pFnt->pszFullName, pFullName );
+  pFnt->pszFontName = pFnt->pszFullName + lFullLen;
+  strcpy( pFnt->pszFontName, pFontName );
+
+  /* Set both of these to the font filename. */
+  pFnt->pszOFM = pFnt->pszFontName + lFontLen;
+  strcpy( pFnt->pszOFM, pFontFileName );
+  pFnt->pszPFB = pFnt->pszOFM + lFileLen;
+  strcpy( pFnt->pszPFB, pFontFileName );
+
+//if (g_debuglog) fprintf(g_debuglog, "Added TrueType font \"%s\" (PS: \"%s\"): %s\n", pFnt->pszFullName, pFnt->pszFontName, pFnt->pszOFM );
+
+  return;
+}
+
+/*****************************************************************************\
+**
+** Convert the TTF to our font struct (using various FNTLIB routines).
+**
+\*****************************************************************************/
+PFONTDEF ConvertTTFtoPFM( PDV pdv, PSZ pszFilename )
+{
+  PFONTDEF    pFD = NULL;
+  PFONTHEADER pFH;
+  PFONTGLOBAL pFG;
+  PBYTE       pB;
+  PCHARWIDTH  pCD;
+  CHARWIDTH   CW,
+              cdSpaceChar;
+  KST0        *pKern;
+  PKERNPAIRS  pKP;
+  BOOL        rc;
+  long        lp;
+  double      mult;
+  char        dt[ TTF_HEADER_SIZE ];
+  char        szFullname[ STR_SIZE ];
+  USHORT      usS;
+  USHORT      usDupGlyph;
+  PSHORT      pWidths;
+  register short sI;
+  LONG        lGlyphCount;
+  TTFDATA     ttfdt;
+  FONTMETRICS fm;
+  AFMData     afmdt;
+  FILE        *ifl;
+
+  /*
+  ** First, parse the FONTMETRICS data from the TTF file.
+  */
+
+  if (( ifl = fopen(pszFilename, "rb")) == NULL )
+     return NULL;
+
+  memset((void *)&fm, 0, sizeof(FONTMETRICS));
+  ttfdt.te = NULL;
+
+  /* read the TTF header */
+  if ( fread( dt, sizeof(char), TTF_HEADER_SIZE, ifl ) == TTF_HEADER_SIZE )
+  {
+    /* get count of table entries */
+    ttfdt.numTE = ((USHORT)dt[4] << 8) + (USHORT)dt[5];
+
+    ttfdt.te = (TBLENT *)malloc(sizeof(TBLENT) * ttfdt.numTE);
+    if (ttfdt.te != (TBLENT *)NULL)
+    {
+      if ( fread( ttfdt.te, sizeof(TBLENT), ttfdt.numTE, ifl ) == ttfdt.numTE )
+      {
+        /* swap all tags */
+        for ( lp = 0; ( lp < (long) ttfdt.numTE ); lp++ )
+          swapTblent(&(ttfdt.te[lp]));
+
+        /*  populate the font metrics and AFM data */
+        if ((PSprocessTags(ifl, &ttfdt, &fm, &afmdt)) && (TTFPopulatePFA(ifl, &ttfdt, &afmdt)))
+        {
+          TBLENT   *pte;
+
+          // PSProcessTags evidently sets this to the PS name, so fix it now
+          if (( pte = getTE(&ttfdt, TT_NAME_TAG)) != NULL ) {
+              rc = getTTFName(pte, ifl, szFullname, TRUE);
+              if ( rc )
+                strncpy( fm.szFacename, szFullname, FACESIZE-1 );
+          }
+
+          fm.sFirstChar = 1;
+          fm.sNominalPointSize = 120;
+          fm.sMinimumPointSize = 10;
+          fm.sMaximumPointSize = 9990;
+          fm.sDefaultChar = 31;
+          fm.sBreakChar = 31;
+          fm.fsDefn = 1;
+          lp = fm.lMaxAscender + fm.lMaxDescender;
+          if (lp > fm.sXDeviceRes)
+            fm.lInternalLeading = lp - fm.sXDeviceRes;
+          else
+            fm.lInternalLeading = 0;
+
+          /* now fix all numbers so that the device resolutions are 1000 */
+          mult = (double)1000 / (double)fm.sXDeviceRes;
+
+          fm.sXDeviceRes = 1000;
+          fm.sYDeviceRes = 1000;
+          afmdt.BBox.left = (SHORT)(afmdt.BBox.left * mult);
+          afmdt.BBox.bottom = (SHORT)(afmdt.BBox.bottom * mult);
+          afmdt.BBox.right = (SHORT)(afmdt.BBox.right * mult);
+          afmdt.BBox.top = (SHORT)(afmdt.BBox.top * mult);
+          afmdt.CapHeight = (SHORT)(afmdt.CapHeight * mult);
+          for (lp=0; lp<MAX_CHARS; lp++)
+            afmdt.CM[lp].x = (SHORT)(afmdt.CM[lp].x * mult);
+
+          fm.lEmHeight = (long)(fm.lEmHeight * mult);
+          fm.lMaxAscender = (long)(fm.lMaxAscender * mult);
+          fm.lMaxDescender = (long)(fm.lMaxDescender * mult);
+          fm.lLowerCaseAscent = (long)(fm.lLowerCaseAscent * mult);
+          fm.lLowerCaseDescent = (long)(fm.lLowerCaseDescent * mult);
+          fm.lInternalLeading = (long)(fm.lInternalLeading * mult);
+          fm.lExternalLeading = (long)(fm.lExternalLeading * mult);
+          fm.lAveCharWidth = (long)(fm.lAveCharWidth * mult);
+          fm.lMaxCharInc = (long)(fm.lMaxCharInc * mult);
+          fm.lEmInc = (long)(fm.lEmInc * mult);
+          fm.lMaxBaselineExt = (long)(fm.lMaxBaselineExt * mult);
+          fm.lSubscriptXSize = (long)(fm.lSubscriptXSize * mult);
+          fm.lSubscriptYSize = (long)(fm.lSubscriptYSize * mult);
+          fm.lSubscriptXOffset = (long)(fm.lSubscriptXOffset * mult);
+          fm.lSubscriptYOffset = (long)(fm.lSubscriptYOffset * mult);
+          fm.lSuperscriptXSize = (long)(fm.lSuperscriptXSize * mult);
+          fm.lSuperscriptYSize = (long)(fm.lSuperscriptYSize * mult);
+          fm.lSuperscriptXOffset = (long)(fm.lSuperscriptXOffset * mult);
+          fm.lSuperscriptYOffset = (long)(fm.lSuperscriptYOffset * mult);
+          fm.lUnderscoreSize = (long)(fm.lUnderscoreSize * mult);
+          fm.lUnderscorePosition = (long)(fm.lUnderscorePosition * mult);
+          fm.lStrikeoutSize = (long)(fm.lStrikeoutSize * mult);
+          fm.lStrikeoutPosition = (long)(fm.lStrikeoutPosition * mult);
+#if 0
+          pKern = NULL;
+          if (( pte = getTE(&ttfdt, TT_KERN_TAG)) != NULL ) {
+            rc = PSprocessKERNTag(ifl, &pKern, pte );
+            fm.sKerningPairs = pKern->nPairs;
+          }
+          else
+             fm.sKerningPairs = 0;
+#endif
+        }
+      }
+      free( ttfdt.te );
+    }
+  }
+
+  if ( ttfdt.te == NULL ) {
+     fclose( ifl );
+     return NULL;
+  }
+
+  /*
+  ** Calculate the size of FONTDEF
+  ** Add up size of FONTDEF + 10 bytes for alignment here and there plus
+  ** number of glyphs * size of CHARWIDTH  plus
+  ** number of kerning pairs * size of KERNINGPAIRS plus
+  ** 2 names font & family
+  ** size of FONTMETRICS
+  */
+  lGlyphCount = fm.sLastChar + 1;
+  usS = sizeof( FONTDEF ) + 10 + sizeof( FONTMETRICS );
+  usS += lGlyphCount * sizeof( CHARWIDTH );
+  usS += fm.sKerningPairs * sizeof( KERNPAIRS );
+  usS += 32 * 2;                    // font name
+
+  /*
+  ** Alocate buffer
+  */
+  if ( (pFD = (PFONTDEF)GplMemoryAlloc( pdv->pDCHeap, usS )) == NULL )
+    return ( pFD );
+
+  /*
+  ** Fill in Font Header
+  */
+  pFH = (PFONTHEADER) pFD;
+  pFH->usVersion = 0;   // Not used anywhere
+  pFH->usGlobalOffset = sizeof( FONTHEADER );
+
+  /*
+  ** Fill in FontGlobal area
+  */
+  pFG = &(pFD->Global);
+  pFG->fVariablePitch = ( fm.fsType & FM_TYPE_FIXED ) ? FALSE : TRUE;
+  pFG->sFontBBox[0] = (SHORT) 0;                    // lower left x -- CHECK THIS
+  pFG->sFontBBox[1] = (SHORT) -(fm.lMaxDescender);  // lower left y
+  pFG->sFontBBox[2] = (SHORT) fm.lMaxCharInc;       // upper right x -- CHECK THIS
+  pFG->sFontBBox[3] = (SHORT) fm.lMaxAscender;      // upper right y
+  pFG->usCapHeight = (USHORT) fm.lXHeight;
+
+  /*
+  ** Point to variable area
+  */
+  pB = (PBYTE)pFD + sizeof( FONTDEF );
+  if ( (ULONG) pB & 1 )
+  {
+    pB++;   /* Word align */
+  }
+
+  pFH->usCharMetricsOffset = (USHORT)(pB - (PBYTE)pFD );
+
+  /*
+  ** Must init the char data to -1 (unused)
+  */
+  pCD = (PCHARWIDTH) pB;
+  usS = (SHORT) lGlyphCount;
+  for ( sI = 0; sI < usS; sI++ )
+  {
+    pCD->glyph = (USHORT)-1;
+    pCD++;
+  }
+
+  // Save the character width data
+  pCD = (PCHARWIDTH) pB;
+  for ( sI = 0; (sI < MAX_CHARS && sI < usS); sI++ )
+  {
+    CW.glyph = sI;
+    CW.wx    = afmdt.CM[sI].x;
+    CW.llx   = 0;
+    CW.urx   = CW.wx;
+
+    *(pCD+(sI-1)) = CW;
+
+    // Copy these duplicate glyphs
+    usDupGlyph = 0;
+    switch( sI )
+    {
+      case  20:           /* "paragraph"   */
+        usDupGlyph = 244;
+        break;
+      case  21:           /* "section"     */
+        usDupGlyph = 245;
+        break;
+    }
+    if ( usDupGlyph )
+      *(pCD+(usDupGlyph-1)) = CW;
+
+  }
+
+  /*
+  ** Use blank char (default) for -1 characters
+  */
+  cdSpaceChar = *(pCD+(' '-1));
+
+  /*
+  ** Loop through all the characters fixing any -1 chars
+  */
+  pCD = (PCHARWIDTH)pB;
+  for ( sI = 0; sI < lGlyphCount; sI++ )
+  {
+    if ( pCD->glyph == (USHORT)-1 )
+    { /*
+      ** Any necessary character that this font does not support will currently
+      ** have ipscriptCode == -1. Force all of these characters to map to (and
+      ** have character metrics of) the default character, typically a blank.
+      */
+      *pCD = cdSpaceChar;
+    }
+    pCD++;
+  }
+
+  /* Even up */
+  if ( (ULONG) ( pB += lGlyphCount * sizeof(CHARWIDTH)) & 1 )
+    pB++;
+
+#if 0
+  /*
+  ** Copy the Kerning Data over
+  */
+  if ( pKern ) {
+    pFH->usKerningDataOffset = (USHORT)(pB - (PBYTE)pFD );
+    usS = (USHORT)fm.sKerningPairs;
+    for ( sI = 0; sI < usS; sI++ )
+    {
+      *((PKERNPAIRS)pB) = (KERNPAIRS)(pKern->pairs[ sI ]);
+      pB += sizeof( KERNPAIRS );
+    }
+
+    // Even up
+    if ( (ULONG) pB & 1 )
+    {
+      pB++;
+    }
+    free( pKern );
+  }
+#else
+  fm.sKerningPairs = 0;
+#endif
+
+  /*
+  ** Set up strings offset -- only font name is needed
+  */
+  pFH->usStringsOffset = (USHORT)(pB - (PBYTE)pFD );
+  CopyStr( (PSZ) pB, (PSZ) fm.szFacename );
+  pB += strlen( fm.szFacename ) + 1;
+
+  /* Even up */
+  if ( (ULONG) pB & 1 )
+  {
+    pB++;
+  }
+
+  /*
+  ** Copy over the font metrics
+  */
+  pFH->usMetricsOffset = (USHORT)(pB - (PBYTE)pFD );
+  utl_memcopy( pB, (PSZ) &fm, sizeof(FONTMETRICS) );
+
+  pB += sizeof( FONTMETRICS );
+  /* Even up */
+  if ( (ULONG) ( pB ) & 1 )
+  {
+    pB++;
+  }
+
+  pB -= pFH->usCharMetricsOffset;
+  pFH->usSectionsSize = OFFSETOF( pB );
+
+  return ( pFD );
+}
+
+
+/*****************************************************************************\
+**
+** SendPFA
+**
+** Read and send a PFA (e.g. Type42) file.  Because this is already straight
+** ASCII PostScript data, all we have to do is copy it straight to the channel.
+**
+\*****************************************************************************/
+
+VOID SendPFA( PDDC pddc,  HFILE hPFA )
+{
+  ULONG  cbRead;
+  PBYTE  pInBuf;
+  USHORT nblocks;
+  USHORT rblocks;
+  USHORT i;
+
+  /*
+  ** Create input buffer
+  */
+  if ( !(pInBuf = GplMemoryAlloc( pddc->pdv->pDCHeap, RWBUFSIZE ) ) )
+  {
+    return;
+  }
+
+  while (( !DosRead( hPFA, (PVOID) pInBuf, RWBUFSIZE, &cbRead )) && cbRead )
+  {
+      WriteChannel( pddc, pInBuf, cbRead );
+  }
+  GplMemoryFree( pInBuf );
+
+  WriteChannel( pddc, " ", 1 );
+
+  return;
+}
+
+
+/*****************************************************************************\
+**                                                                          **
+**              NEW ROUTINES SPECIFIC TO OPENTYPE/CFF SUPPORT               **
+**                                                                          **
+\*****************************************************************************/
+
+
+/*****************************************************************************\
+**
+** IsOTFFile
+**
+** Checks supplied name to see if it ends in .otf.  If true returns positive
+** length.  If false returns negative length.
+**
+\*****************************************************************************/
+
+LONG IsOTFFile( PSZ pszName )
+{
+  register SHORT sLength1;
+  register SHORT sLength2;
+  SHORT          sSign = -1;
+
+  sLength1 = strlen( pszName );
+
+  // Find the (last) dot if there is one
+  while ( sLength1 &&
+          pszName[sLength1-1] != '.' )
+  {
+    sLength1--;
+  }
+  if ( sLength1 )
+     pszName += (--sLength1);
+
+  /*
+  ** if there are 4 chars left and they are ".OTF" set up positive return
+  */
+  if ( (sLength2 = strlen( pszName )) == 4 )
+  {
+    if ( *(pszName+1) == 'O' &&
+         *(pszName+2) == 'T' &&
+         *(pszName+3) == 'F')
+      sSign = 1;
+  }
+
+  return ( sLength1 + sLength2 ) * sSign;
+}
+
+
+#ifdef OPENTYPE_SUPPORT
+
+/*****************************************************************************\
+**
+** GetOTFInfo
+**
+** Read the OT tables in an OpenType font to determine if it contains TrueType
+** or PostScript/CFF outlines, and also parses out the "normal" and "PostScript"
+** font names.  Returns the OTF_TYPE_* font type flag, or OTF_INVALID if the
+** font is invalid.  Largely based on isFileTTFont(); uses FNTLIB.
+**
+**  PSZ pszFile    OTF filename to be parsed
+**  PSZ pszName    Buffer to receive full name of font
+**  PSZ pszPSName  Buffer to receive PostScript name of font
+**
+\*****************************************************************************/
+CHAR GetOTFInfo( PSZ pszFile, PSZ pszName, PSZ pszPSName )
+{
+  FILE      *fl;
+  UCHAR     data[TTF_HEADER_SIZE];
+  USHORT    tblents;
+  USHORT    lp;
+  TBLENT    *te;
+  CHAR      ftype;
+  long      fndtags;
+
+  /* init variables */
+  fndtags = 0;
+  ftype = OTF_INVALID;
+  pszName[0] = '\0';
+  pszPSName[0] = '\0';
+
+  /* open the file */
+  fl = fopen(pszFile, "rb");
+  if (fl != NULL)
+  {
+    /* read the OTF header */
+    if (fread(data, sizeof(char), TTF_HEADER_SIZE, fl) == TTF_HEADER_SIZE)
+    {
+      /* if the version is valid */
+      if ((data[0] == 0x00) && (data[1] == 0x01) && (data[2] == 0x00) &&
+          (data[3] == 0x00))
+      {
+        /* get count of table entries */
+        tblents = ((USHORT)data[4] << 8) + (USHORT)data[5];
+
+        te = (TBLENT *)malloc(sizeof(TBLENT) * tblents);
+        if (te != (TBLENT *)NULL)
+        {
+          if (fread(te, sizeof(TBLENT), tblents, fl) == tblents)
+          {
+            for (lp = 0; lp < tblents; lp++)
+            {
+              swapTblent(&te[lp]);
+              switch(te[lp].tag)
+              {
+
+                case TT_NAME_TAG:
+                  getTTFName(&te[lp], fl, pszPSName, FALSE);
+                  getTTFName(&te[lp], fl, pszName,   TRUE);
+                  fndtags |= FOUND_NAME_TAG;
+                  break;
+
+                case TT_CFF__TAG:
+                  ftype = OTF_TYPE_CFF;
+                  break;
+
+                case TT_GLYF_TAG:
+                  ftype = OTF_TYPE_TTF;
+                  //fndtags |= FOUND_GLYF_TAG;
+                  break;
+
+                case TT_CMAP_TAG:
+                  fndtags |= FOUND_CMAP_TAG;
+                  break;
+
+                case TT_OS_2_TAG:
+                  fndtags |= FOUND_OS_2_TAG;
+                  break;
+
+                case TT_HEAD_TAG:
+                  fndtags |= FOUND_HEAD_TAG;
+                  break;
+
+                case TT_HHEA_TAG:
+                  fndtags |= FOUND_HHEA_TAG;
+                  break;
+
+                case TT_HMTX_TAG:
+                  fndtags |= FOUND_HMTX_TAG;
+                  break;
+
+                case TT_MAXP_TAG:
+                  fndtags |= FOUND_MAXP_TAG;
+                  break;
+
+                case TT_POST_TAG:
+                  fndtags |= FOUND_POST_TAG;
+                  break;
+
+                default:
+                  break;
+              }
+            }
+          }
+          free(te);
+        }
+      }
+    }
+    fclose(fl);
+  }
+
+  if ( pszName[0] && pszPSName[0] && (( fndtags & OTF_REQUIRED_TAGS) == OTF_REQUIRED_TAGS ))
+     return ftype;
+
+  return OTF_INVALID;
+}
+
+
+/*****************************************************************************\
+**
+** ConvertOTFtoPFM
+**
+** Populate our font metrics struct from an OpenType/PS font.  This requires
+** some changes from ConvertTTFtoPFM, as an OTF/PS font doesn't have some of
+** the tables assumed by FNTLIB to be present in a TTF.  (PSprocessTags and
+** PSfillTTFheader (called by TTFPopulatePFA) are the main culprits, as they
+** assume GLYF and LOCA will always exist.  We replace the former and modify
+** the latter.)
+**
+** TODO Confirm GlyphOffset and LocaOffset in ttfdt aren't used by anything
+\*****************************************************************************/
+PFONTDEF ConvertOTFtoPFM( PDV pdv, PSZ pszFilename )
+{
+  PFONTDEF    pFD = NULL;
+  PFONTHEADER pFH;
+  PFONTGLOBAL pFG;
+  PBYTE       pB;
+  PCHARWIDTH  pCD;
+  CHARWIDTH   CW,
+              cdSpaceChar;
+  BOOL        rc;
+  long        lp;
+  double      mult;
+  char        dt[ TTF_HEADER_SIZE ];
+  char        szFullname[ STR_SIZE ];
+  USHORT      usS;
+  USHORT      usDupGlyph;
+  PSHORT      pWidths;
+  register short sI;
+  LONG        lGlyphCount;
+  TTFDATA     ttfdt;
+  FONTMETRICS fm;
+  AFMData     afmdt;
+  FILE        *ifl;
+
+  /*
+  ** First, parse the FONTMETRICS data from the TTF file.
+  */
+
+  if (( ifl = fopen(pszFilename, "rb")) == NULL )
+     return NULL;
+
+  memset((void *)&fm, 0, sizeof(FONTMETRICS));
+  ttfdt.te = NULL;
+
+  /* read the TTF header */
+  if ( fread( dt, sizeof(char), TTF_HEADER_SIZE, ifl ) == TTF_HEADER_SIZE )
+  {
+    /* get count of table entries */
+    ttfdt.numTE = ((USHORT)dt[4] << 8) + (USHORT)dt[5];
+
+    ttfdt.te = (TBLENT *)malloc(sizeof(TBLENT) * ttfdt.numTE);
+    if (ttfdt.te != (TBLENT *)NULL)
+    {
+      if ( fread( ttfdt.te, sizeof(TBLENT), ttfdt.numTE, ifl ) == ttfdt.numTE )
+      {
+        /* swap all tags */
+        for ( lp = 0; ( lp < (long) ttfdt.numTE ); lp++ )
+          swapTblent(&(ttfdt.te[lp]));
+
+        /*  populate the font metrics and AFM data */
+        if ((PSprocessCFFTags(ifl, &ttfdt, &fm, &afmdt)) && (OTFPopulatePFA(ifl, &ttfdt, &afmdt)))
+        {
+          TBLENT   *pte;
+
+          // PSProcessTags evidently sets this to the PS name, so fix it now
+          if (( pte = getTE(&ttfdt, TT_NAME_TAG)) != NULL ) {
+              if ( getTTFName(pte, ifl, szFullname, TRUE))
+                strncpy( fm.szFacename, szFullname, FACESIZE-1 );
+          }
+
+          fm.sFirstChar = 1;
+          fm.sNominalPointSize = 120;
+          fm.sMinimumPointSize = 10;
+          fm.sMaximumPointSize = 9990;
+          fm.sDefaultChar = 31;
+          fm.sBreakChar = 31;
+          fm.fsDefn = 1;
+          lp = fm.lMaxAscender + fm.lMaxDescender;
+          if (lp > fm.sXDeviceRes)
+            fm.lInternalLeading = lp - fm.sXDeviceRes;
+          else
+            fm.lInternalLeading = 0;
+
+          /* now fix all numbers so that the device resolutions are 1000 */
+          mult = (double)1000 / (double)fm.sXDeviceRes;
+
+          fm.sXDeviceRes = 1000;
+          fm.sYDeviceRes = 1000;
+          afmdt.BBox.left = (SHORT)(afmdt.BBox.left * mult);
+          afmdt.BBox.bottom = (SHORT)(afmdt.BBox.bottom * mult);
+          afmdt.BBox.right = (SHORT)(afmdt.BBox.right * mult);
+          afmdt.BBox.top = (SHORT)(afmdt.BBox.top * mult);
+          afmdt.CapHeight = (SHORT)(afmdt.CapHeight * mult);
+          for (lp=0; lp<MAX_CHARS; lp++)
+            afmdt.CM[lp].x = (SHORT)(afmdt.CM[lp].x * mult);
+
+          fm.lEmHeight = (long)(fm.lEmHeight * mult);
+          fm.lMaxAscender = (long)(fm.lMaxAscender * mult);
+          fm.lMaxDescender = (long)(fm.lMaxDescender * mult);
+          fm.lLowerCaseAscent = (long)(fm.lLowerCaseAscent * mult);
+          fm.lLowerCaseDescent = (long)(fm.lLowerCaseDescent * mult);
+          fm.lInternalLeading = (long)(fm.lInternalLeading * mult);
+          fm.lExternalLeading = (long)(fm.lExternalLeading * mult);
+          fm.lAveCharWidth = (long)(fm.lAveCharWidth * mult);
+          fm.lMaxCharInc = (long)(fm.lMaxCharInc * mult);
+          fm.lEmInc = (long)(fm.lEmInc * mult);
+          fm.lMaxBaselineExt = (long)(fm.lMaxBaselineExt * mult);
+          fm.lSubscriptXSize = (long)(fm.lSubscriptXSize * mult);
+          fm.lSubscriptYSize = (long)(fm.lSubscriptYSize * mult);
+          fm.lSubscriptXOffset = (long)(fm.lSubscriptXOffset * mult);
+          fm.lSubscriptYOffset = (long)(fm.lSubscriptYOffset * mult);
+          fm.lSuperscriptXSize = (long)(fm.lSuperscriptXSize * mult);
+          fm.lSuperscriptYSize = (long)(fm.lSuperscriptYSize * mult);
+          fm.lSuperscriptXOffset = (long)(fm.lSuperscriptXOffset * mult);
+          fm.lSuperscriptYOffset = (long)(fm.lSuperscriptYOffset * mult);
+          fm.lUnderscoreSize = (long)(fm.lUnderscoreSize * mult);
+          fm.lUnderscorePosition = (long)(fm.lUnderscorePosition * mult);
+          fm.lStrikeoutSize = (long)(fm.lStrikeoutSize * mult);
+          fm.lStrikeoutPosition = (long)(fm.lStrikeoutPosition * mult);
+        }
+      }
+      free( ttfdt.te );
+    }
+  }
+
+  if ( ttfdt.te == NULL ) {
+     fclose( ifl );
+     return NULL;
+  }
+
+  /*
+  ** Calculate the size of FONTDEF
+  ** Add up size of FONTDEF + 10 bytes for alignment here and there plus
+  ** number of glyphs * size of CHARWIDTH  plus
+  ** number of kerning pairs * size of KERNINGPAIRS plus
+  ** 2 names font & family
+  ** size of FONTMETRICS
+  */
+  lGlyphCount = fm.sLastChar + 1;
+  usS = sizeof( FONTDEF ) + 10 + sizeof( FONTMETRICS );
+  usS += lGlyphCount * sizeof( CHARWIDTH );
+  usS += fm.sKerningPairs * sizeof( KERNPAIRS );
+  usS += 32 * 2;                    // font name
+
+  /*
+  ** Alocate buffer
+  */
+  if ( (pFD = (PFONTDEF)GplMemoryAlloc( pdv->pDCHeap, usS )) == NULL )
+    return ( pFD );
+
+  /*
+  ** Fill in Font Header
+  */
+  pFH = (PFONTHEADER) pFD;
+  pFH->usVersion = 0;   // Not used anywhere
+  pFH->usGlobalOffset = sizeof( FONTHEADER );
+
+  /*
+  ** Fill in FontGlobal area
+  */
+  pFG = &(pFD->Global);
+  pFG->fVariablePitch = ( fm.fsType & FM_TYPE_FIXED ) ? FALSE : TRUE;
+  pFG->sFontBBox[0] = (SHORT) 0;                    // lower left x -- CHECK THIS
+  pFG->sFontBBox[1] = (SHORT) -(fm.lMaxDescender);  // lower left y
+  pFG->sFontBBox[2] = (SHORT) fm.lMaxCharInc;       // upper right x -- CHECK THIS
+  pFG->sFontBBox[3] = (SHORT) fm.lMaxAscender;      // upper right y
+  pFG->usCapHeight = (USHORT) fm.lXHeight;
+
+  /*
+  ** Point to variable area
+  */
+  pB = (PBYTE)pFD + sizeof( FONTDEF );
+  if ( (ULONG) pB & 1 )
+  {
+    pB++;   /* Word align */
+  }
+
+  pFH->usCharMetricsOffset = (USHORT)(pB - (PBYTE)pFD );
+
+  /*
+  ** Must init the char data to -1 (unused)
+  */
+  pCD = (PCHARWIDTH) pB;
+  usS = (SHORT) lGlyphCount;
+  for ( sI = 0; sI < usS; sI++ )
+  {
+    pCD->glyph = (USHORT)-1;
+    pCD++;
+  }
+
+  // Save the character width data
+  pCD = (PCHARWIDTH) pB;
+  for ( sI = 0; (sI < MAX_CHARS && sI < usS); sI++ )
+  {
+    CW.glyph = sI;
+    CW.wx    = afmdt.CM[sI].x;
+    CW.llx   = 0;
+    CW.urx   = CW.wx;
+
+    *(pCD+(sI-1)) = CW;
+
+    // Copy these duplicate glyphs
+    usDupGlyph = 0;
+    switch( sI )
+    {
+      case  20:           /* "paragraph"   */
+        usDupGlyph = 244;
+        break;
+      case  21:           /* "section"     */
+        usDupGlyph = 245;
+        break;
+    }
+    if ( usDupGlyph )
+      *(pCD+(usDupGlyph-1)) = CW;
+
+  }
+
+  /*
+  ** Use blank char (default) for -1 characters
+  */
+  cdSpaceChar = *(pCD+(' '-1));
+
+  /*
+  ** Loop through all the characters fixing any -1 chars
+  */
+  pCD = (PCHARWIDTH)pB;
+  for ( sI = 0; sI < lGlyphCount; sI++ )
+  {
+    if ( pCD->glyph == (USHORT)-1 )
+    { /*
+      ** Any necessary character that this font does not support will currently
+      ** have ipscriptCode == -1. Force all of these characters to map to (and
+      ** have character metrics of) the default character, typically a blank.
+      */
+      *pCD = cdSpaceChar;
+    }
+    pCD++;
+  }
+
+  /* Even up */
+  if ( (ULONG) ( pB += lGlyphCount * sizeof(CHARWIDTH)) & 1 )
+    pB++;
+
+  /* CFF fonts don't have a KERN table */
+  fm.sKerningPairs = 0;
+  pFH->usKerningDataOffset = (USHORT)(pB - (PBYTE)pFD );
+
+  /*
+  ** Set up strings offset -- only font name is needed
+  */
+  pFH->usStringsOffset = (USHORT)(pB - (PBYTE)pFD );
+  CopyStr( (PSZ) pB, (PSZ) fm.szFacename );
+  pB += strlen( fm.szFacename ) + 1;
+
+  /* Even up */
+  if ( (ULONG) pB & 1 )
+  {
+    pB++;
+  }
+
+  /*
+  ** Copy over the font metrics
+  */
+  pFH->usMetricsOffset = (USHORT)(pB - (PBYTE)pFD );
+  utl_memcopy( pB, (PSZ) &fm, sizeof(FONTMETRICS) );
+
+  pB += sizeof( FONTMETRICS );
+  /* Even up */
+  if ( (ULONG) ( pB ) & 1 )
+  {
+    pB++;
+  }
+
+  pB -= pFH->usCharMetricsOffset;
+  pFH->usSectionsSize = OFFSETOF( pB );
+
+  return ( pFD );
+}
+
+
+/*****************************************************************************\
+**
+** CreateCFFFontSet
+**
+** Convert an OpenType/CFF font into a PFA FontSet resource (containing
+** the CFF data encoded in ASCII85 format) which can be placed into the
+** output PostScript stream like any other resource.
+**
+\*****************************************************************************/
+BOOL CreateCFFFontSet( PFONT_PROFILE prFontProfile )
+{
+   char  szShortName[CCHMAXPATH];
+   char  targetFile[CCHMAXPATH];
+   char  dt[ TTF_HEADER_SIZE ];     // buffer for reading OTF header
+   char  achPSName[ STR_SIZE ];     // device (PS) name of the font
+   char  buff[256];                 // file write buffer
+   FILE  *ifl;                      // input (OTF) file
+   FILE  *PFAfl;                    // output (PFA) file
+   LONG  len;
+   PBYTE pbCFF = NULL;
+   PBYTE pbA85 = NULL;
+   BOOL  rc = FALSE;
+
+   TTFDATA   ttfdt;
+
+
+  /* fontdir + \ + 8 + . + 3 is to long if it is greater than MAXPATH */
+  if ((strlen(prFontProfile->szPrinterOutput) + 13) <= CCHMAXPATH)
+  {
+    /* Build the target sfs file */
+    strcpy(targetFile, prFontProfile->szPrinterOutput);
+    appendBaseName(targetFile, prFontProfile->szFontBinary);
+
+    if (FixName(targetFile, ".pfa", NULL))
+    {
+      /* copy the new basename to the shortname */
+      ShortName[0] = '\0';
+      appendBaseName(ShortName, targetFile);
+
+      ifl = fopen(filename, "rb");
+      if (ifl != (FILE *)NULL)
+      {
+        /* open the PFM file */
+        PFAfl = fopen(targetFile, "wb");
+        if (PFAfl != (FILE *)NULL)
+        {
+
+          /* read the OTF header */
+          if ( fread( dt, sizeof(char), TTF_HEADER_SIZE, ifl ) == TTF_HEADER_SIZE )
+          {
+            /* get count of table entries */
+            ttfdt.numTE = ((USHORT)dt[4] << 8) + (USHORT)dt[5];
+            ttfdt.te = (TBLENT *)malloc(sizeof(TBLENT) * ttfdt.numTE);
+            if ((ttfdt.te != (TBLENT *)NULL) &&
+                ( fread( ttfdt.te, sizeof(TBLENT), ttfdt.numTE, ifl ) == ttfdt.numTE ))
+            {
+              /* get the font's PostScript name */
+              if (( pte = getTE( &ttfdt, TT_NAME_TAG)) != NULL )
+                rc = getTTFName( pte, fl, achPSName, FALSE );
+              else
+                rc = FALSE;
+
+              /* find the CFF table */
+              if ( rc && ( pte = getTE(&ttfdt, TT_CFF__TAG)) != NULL ) {
+
+                pbCFF = (PBYTE) malloc( pte->length );
+                if (pbCFF != NULL)
+                {
+                  fseek(ifl, pte->offset, SEEK_SET);
+                  if (fread(pbCFF, pte->length, 1, fl) == 1)
+                  {
+                    /* write FontSet resource header to PFA */
+                    sprintf(buff, "%%!PS-Adobe-3.0 Resource-FontSet\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%DocumentNeededResources: ProcSet (FontSetInit)\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%Title: (FontSet/%s)\n", achPSName );
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%IncludeResource: ProcSet (FontSetInit)\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%BeginResource: FontSet (%s)\n", );
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "/FontSetInit /ProcSet findresource begin\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%BeginData: %u Binary Bytes\n", pte->length );
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "/%s %u\n", achPSName, pte->length );
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "currentfile /ASCII85Decode filter cvx exec\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+
+                    rc = FALSE;
+                    pbA85 = (PBYTE) calloc(( pte->length * 5 / 4 ) + 1, sizeof(BYTE));
+                    if ( pbA85 ) {
+                      /* convert CFF data to Ascii85 and write to PFA */
+                      len = GplCompressAscii85( pbCFF, pbA85, pte->length );
+                      if ( len > 0 ) {
+                        int offs, remain, seg;
+                        for ( offs = 0; ofs < len; offs += 254; )
+                        {
+                          remain = len - offs;
+                          seg = min( 254, remain );
+                          memcpy(buff, pbA85+offs, seg);
+                          buff[seg] = '\n';
+                          fwrite(buff, 1, seg+1, PFAfl);
+                        }
+                        rc = TRUE;
+                      }
+                      free( pbA85 );
+                    }
+
+                    /* finish and close PFA */
+                    sprintf(buff, "%%%%EndData\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%EndResource\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%EOF\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                    sprintf(buff, "%%%%EndResource\n");
+                    fwrite(buff, 1, strlen(buff), PFAfl);
+                  }
+                  free(pbCFF);
+                }
+              }
+            }
+          }
+          fclose(PFAfl);
+        }
+        fclose(ifl);
+
+        /* if we failed, delete the output files */
+        if (!rc)
+        {
+          /* delete the PFM file */
+          DeleteFile(targetFile);
+
+          /* convert file type to "PFA" */
+          len = strlen(targetFile);
+          targetFile[len-3] = 'P';
+          targetFile[len-2] = 'F';
+          targetFile[len-1] = 'A';
+
+          /* delete the PFA file */
+          DeleteFile(targetFile);
+        }
+      }
+    }
+  }
+
+  if ( rc )
+    strcat(prFontProfile->szPrinterOutput, szShortName);
+
+  return rc;
+}
+
+#endif
+// ALT_PSPRINT
+
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/afm2bin.c src\osdd\pscript\psprint/fntlib/afm2bin.c
--- src\osdd\pscript\post32/fntlib/afm2bin.c	Tue Nov 11 18:10:46 2003
+++ src\osdd\pscript\psprint/fntlib/afm2bin.c	Sat Nov 13 19:10:42 2010
@@ -156,6 +156,7 @@
 /* define AFM2BIN_C so that statics will get created */
 #define AFM2BIN_C
 
+#include "..\inc\common.h"
 #include "afm2bin.h"
 #include "mapping.h"
 
@@ -163,7 +164,7 @@
 
 
 static UCHAR pfmBuffer[MAX_PFM_BUFFER];
-static long pbpos;
+static long pbpos = 0;
 
 
 BOOL putByte(FILE *ofl, UCHAR b)
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/inc/afm2bin.h src\osdd\pscript\psprint/fntlib/inc/afm2bin.h
--- src\osdd\pscript\post32/fntlib/inc/afm2bin.h	Tue Nov 11 18:12:44 2003
+++ src\osdd\pscript\psprint/fntlib/inc/afm2bin.h	Thu Nov 11 11:21:34 2010
@@ -13,6 +13,11 @@
 
 #define AFM2BIN_H
 
+
+#ifndef OS2D2_H
+    #include "os2d2.h"
+#endif
+
 /* values of sFamilyClass */
 #define  FATTR_FAM_NO_CLASSIFICATION  0
 #define  FATTR_FAM_OLD_STYLE_SERIF    1
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/inc/ifnt2fns.h src\osdd\pscript\psprint/fntlib/inc/ifnt2fns.h
--- src\osdd\pscript\post32/fntlib/inc/ifnt2fns.h	Tue Nov 11 18:12:44 2003
+++ src\osdd\pscript\psprint/fntlib/inc/ifnt2fns.h	Thu Oct 14 11:16:16 2010
@@ -13,6 +13,9 @@
 #define UNBOUND_WIDTH_CNT   383
 #define DEFAULT_CHAR        32
 
+#ifndef OS2D2_H
+    #include "os2d2.h"
+#endif
 
 typedef struct {
   short   ch1;
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/inc/os2d2.h src\osdd\pscript\psprint/fntlib/inc/os2d2.h
--- src\osdd\pscript\post32/fntlib/inc/os2d2.h	Thu Jan  1 00:00:00 1970
+++ src\osdd\pscript\psprint/fntlib/inc/os2d2.h	Mon Nov 15 23:52:34 2010
@@ -0,0 +1,84 @@
+/*****************************************************************************/
+/* Include file for missing definitions normally provided by <os2def.h>.     */
+/*****************************************************************************/
+
+#ifndef OS2D2_H
+#define OS2D2_H
+
+#define FACESIZE 32
+
+typedef struct _PANOSE
+{
+   BYTE    bFamilyType;
+   BYTE    bSerifStyle;
+   BYTE    bWeight;
+   BYTE    bProportion;
+   BYTE    bContrast;
+   BYTE    bStrokeVariation;
+   BYTE    bArmStyle;
+   BYTE    bLetterform;
+   BYTE    bMidline;
+   BYTE    bXHeight;
+   BYTE    fbPassedISO;
+   BYTE    fbFailedISO;
+} PANOSE;
+
+typedef struct _FONTMETRICS
+{
+   CHAR    szFamilyname[FACESIZE];
+   CHAR    szFacename[FACESIZE];
+   USHORT  idRegistry;
+   USHORT  usCodePage;
+   LONG    lEmHeight;
+   LONG    lXHeight;
+   LONG    lMaxAscender;
+   LONG    lMaxDescender;
+   LONG    lLowerCaseAscent;
+   LONG    lLowerCaseDescent;
+   LONG    lInternalLeading;
+   LONG    lExternalLeading;
+   LONG    lAveCharWidth;
+   LONG    lMaxCharInc;
+   LONG    lEmInc;
+   LONG    lMaxBaselineExt;
+   SHORT   sCharSlope;
+   SHORT   sInlineDir;
+   SHORT   sCharRot;
+   USHORT  usWeightClass;
+   USHORT  usWidthClass;
+   SHORT   sXDeviceRes;
+   SHORT   sYDeviceRes;
+   SHORT   sFirstChar;
+   SHORT   sLastChar;
+   SHORT   sDefaultChar;
+   SHORT   sBreakChar;
+   SHORT   sNominalPointSize;
+   SHORT   sMinimumPointSize;
+   SHORT   sMaximumPointSize;
+   USHORT  fsType;
+   USHORT  fsDefn;
+   USHORT  fsSelection;
+   USHORT  fsCapabilities;
+   LONG    lSubscriptXSize;
+   LONG    lSubscriptYSize;
+   LONG    lSubscriptXOffset;
+   LONG    lSubscriptYOffset;
+   LONG    lSuperscriptXSize;
+   LONG    lSuperscriptYSize;
+   LONG    lSuperscriptXOffset;
+   LONG    lSuperscriptYOffset;
+   LONG    lUnderscoreSize;
+   LONG    lUnderscorePosition;
+   LONG    lStrikeoutSize;
+   LONG    lStrikeoutPosition;
+   SHORT   sKerningPairs;
+   SHORT   sFamilyClass;
+   LONG    lMatch;
+   LONG    FamilyNameAtom;
+   LONG    FaceNameAtom;
+   PANOSE  panose;
+} FONTMETRICS;
+typedef FONTMETRICS *PFONTMETRICS;
+
+#endif
+
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/inc/runtime2.h src\osdd\pscript\psprint/fntlib/inc/runtime2.h
--- src\osdd\pscript\post32/fntlib/inc/runtime2.h	Thu Jan  1 00:00:00 1970
+++ src\osdd\pscript\psprint/fntlib/inc/runtime2.h	Sat Nov 13 19:16:10 2010
@@ -0,0 +1,27 @@
+#ifndef RUNTIME2_INCLUDED
+#define RUNTIME2_INCLUDED
+
+#include <ctype.h>
+
+#define _fopen  fopen
+#define _fseek  fseek
+#define _fread  fread
+#define _fwrite fwrite
+#define _fclose fclose
+#define _feof   feof
+#define _fgets  fgets
+#define _fputs  fputs
+#define _ftell  ftell
+
+#define _opentmpfile( tfname, tflen )  tmpfile()
+
+#define _remove remove
+#define __mkdir mkdir
+#define __getcwd _getcwd
+
+#define _strnicmp strnicmp
+#define _strlwr   strlwr
+#define _isdigit  isdigit
+#define _isspace  isspace
+
+#endif
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/inc/ttf.h src\osdd\pscript\psprint/fntlib/inc/ttf.h
--- src\osdd\pscript\post32/fntlib/inc/ttf.h	Tue Nov 11 18:12:44 2003
+++ src\osdd\pscript\psprint/fntlib/inc/ttf.h	Wed Aug 21 21:51:04 2013
@@ -55,6 +55,20 @@
                        FOUND_MAXP_TAG | FOUND_NAME_TAG | FOUND_LOCA_TAG |  \
                        FOUND_POST_TAG)
 
+// ALT_PSPRINT
+#ifdef OPENTYPE_SUPPORT
+/* Tables unique to OpenType/PS fonts */
+#define TT_CFF__TAG      0x63666620
+
+#define FOUND_CFF__TAG   0x00010000
+
+/* Tables that must always exist in both TrueType and OpenType/PS fonts */
+#define OTF_REQUIRED_TAGS (FOUND_OS_2_TAG | FOUND_CMAP_TAG | FOUND_HEAD_TAG | \
+                           FOUND_HHEA_TAG | FOUND_HMTX_TAG | FOUND_MAXP_TAG | \
+                           FOUND_NAME_TAG | FOUND_POST_TAG)
+#endif
+// ALT_PSPRINT
+
 #pragma pack(1)
 
 typedef struct {
@@ -359,6 +373,37 @@
   USHORT   numOfHMetrics;
 } HHEATAGDATA;
 
+// ALT_PSPRINT
+/* Don't use KERNPAIRS here because it's defined differently in ifnt2fns.h */
+typedef struct {
+  USHORT   left;
+  USHORT   right;
+  SHORT    value;
+} KERNPAIR;
+
+typedef struct {
+  USHORT    nPairs;
+  USHORT    searchRange;
+  USHORT    entrySelector;
+  USHORT    rangeShift;
+  KERNPAIR  pairs[1];
+} KST0;
+
+typedef struct {
+  USHORT    version;
+  USHORT    length;
+  BYTE      format;
+  BYTE      coverage;
+  KST0      data;
+} KERNSUB;
+
+typedef struct {
+  USHORT    version;
+  USHORT    nTables;
+  CHAR      subtables[1];
+} KERNTAGDATA;
+// ALT_PSPRINT
+
 typedef struct {
   USHORT   advWidth;
   SHORT    lsb;
@@ -373,6 +418,7 @@
   TBLENT   te[9];
 } PSTTFHDR;
 
+
 #pragma pack()
 
 extern BOOL isFileTTFont(char *fn, char *name, long *ptf);
@@ -391,9 +437,13 @@
 extern void swapPOSTData(POSTTAGDATA *pdt);
 extern void swapMAXPData(MAXPTAGDATA *pdt);
 extern void swapHHEAData(HHEATAGDATA *pdt);
+// ALT_PSPRINT
+extern void swapKERNSub0Data(KST0 *pdt);
+extern void swapKERNSubHeader(KERNSUB *pdt);
+extern void swapKERNData(KERNTAGDATA *pdt);
+// ALT_PSPRINT
 extern TBLENT *getTE(TTFDATA *pttfdt, long tag);
 extern USHORT getCharWidth(FILE *fl, USHORT idx, TTFDATA *pttfdt);
 extern BOOL getTTFName(TBLENT *te, FILE *fl, char *name, BOOL fDevName);
 extern BOOL validTTFCMap(TBLENT *te, FILE *fl);
-
 
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/ttf.c src\osdd\pscript\psprint/fntlib/ttf.c
--- src\osdd\pscript\post32/fntlib/ttf.c	Tue Nov 11 18:10:48 2003
+++ src\osdd\pscript\psprint/fntlib/ttf.c	Sat Aug 31 22:39:08 2013
@@ -184,6 +184,33 @@
   swap2((USHORT *)&pdt->lsb);
 }
 
+// ALT
+void swapKERNSub0Data(KST0 *pdt)
+{
+  USHORT i;
+  swap2((USHORT *)&pdt->nPairs);
+  swap2((USHORT *)&pdt->searchRange);
+  swap2((USHORT *)&pdt->entrySelector);
+  swap2((USHORT *)&pdt->rangeShift);
+  for ( i = 0; i < pdt->nPairs; i++ ) {
+    swap2((USHORT *)&pdt->pairs[i].left);
+    swap2((USHORT *)&pdt->pairs[i].right);
+    swap2((USHORT *)&pdt->pairs[i].value);
+  }
+}
+
+void swapKERNSubHeader(KERNSUB *pdt)
+{
+  swap2((USHORT *)&pdt->version );
+  swap2((USHORT *)&pdt->length );
+}
+
+void swapKERNData(KERNTAGDATA *pdt)
+{
+  swap2((USHORT *)&pdt->version );
+  swap2((USHORT *)&pdt->nTables );
+}
+// ALT
 
 void swapType15Header(TYPE15HEADER *pdt)
 {
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fntlib/ttfps.c src\osdd\pscript\psprint/fntlib/ttfps.c
--- src\osdd\pscript\post32/fntlib/ttfps.c	Tue Nov 11 18:10:48 2003
+++ src\osdd\pscript\psprint/fntlib/ttfps.c	Fri Aug 23 10:46:32 2013
@@ -157,10 +157,12 @@
 #include "afm2bin.h"
 #include "ttfmap.h"
 #include "ttf.h"
+#ifndef OS2D2_H
+    #include "os2d2.h"
+#endif
 
 extern CharData StdMapping[];
 
-
 #define PS_NAME_SIZE      80
 #define MAX_PS_STR_SIZE   32768
 
@@ -319,21 +321,31 @@
   /* don't need to check return from getTE(), since always have tag */
   /* we want, that LOCA will be always before GLYF */
   pte = getTE(pttfdt, TT_LOCA_TAG);
+#ifdef OPENTYPE_SUPPORT
+  if (pte != (TBLENT *)NULL)
+#endif
+  {
   pth->te[lp].tag = pte->tag;
   pth->te[lp].checksum = pte->checksum;
   pth->te[lp].offset = len;
   pth->te[lp].length = pte->length;
   len += ((pte->length + 3) & 0xFFFFFFFC);
   lp++;
+  }
 
   /* don't need to check return from getTE(), since always have tag */
   pte = getTE(pttfdt, TT_GLYF_TAG);
+#ifdef OPENTYPE_SUPPORT
+  if (pte != (TBLENT *)NULL)
+#endif
+  {
   pth->te[lp].tag = pte->tag;
   pth->te[lp].checksum = pte->checksum;
   pth->te[lp].offset = len;
   pth->te[lp].length = pte->length;
   len += ((pte->length + 3) & 0xFFFFFFFC);
   lp++;
+  }
 
   /* now calculate some values from the number of table entries */
   if (pth->numTE < 8)
@@ -1093,6 +1105,64 @@
 }
 
 
+// ALT
+/* Retrieve the kerning pairs table.
+ * The caller will be responsible for free()ing ppdt.
+ */
+BOOL PSprocessKERNTag(FILE *fl, KST0 **ppdt, TBLENT *pte)
+{
+  KERNTAGDATA *pkern;
+  KERNSUB     *pkst;
+  USHORT      subt;
+  ULONG       cb;
+  BOOL        rc = FALSE;
+
+  pkern = (KERNTAGDATA *)malloc( pte->length );
+  if (pkern == NULL)
+    return(rc);
+
+  _fseek(fl, pte->offset, SEEK_SET);
+  if (_fread(pkern, pte->length, 1, fl) != 1)
+    goto KERN_finish;
+
+  swapKERNData(pkern);
+  if (pkern->nTables < 1)
+    goto KERN_finish;
+
+  /* Look for a format 0 subtable (don't support other formats). */
+  subt = 0;
+  pkst = (KERNSUB *)(pkern->subtables);
+  swapKERNSubHeader(pkst);
+
+#if 0   // Just check the first subtable - should almost always be sufficient.
+  while ((pkst->format != 0) && (subt < pkern->nTables)) {
+    pkst = (PVOID)(pkst + pkst->length);
+    swapKERNSubHeader(pkst);
+    subt++;
+  }
+#endif
+  if (pkst->format != 0)
+    goto KERN_finish;
+
+  swapKERNSub0Data(&(pkst->data));
+
+  cb = (pkst->data.nPairs * sizeof(KST0)) + 8;
+  if (((ULONG)pkst + cb ) > ((ULONG)pkern + pte->length))
+    goto KERN_finish;
+  *ppdt = (KST0 *)malloc(cb);
+  if (*ppdt == NULL )
+    goto KERN_finish;
+
+  memcpy(*ppdt, &(pkst->data), cb);
+  rc = TRUE;
+
+KERN_finish:
+  free(pkern);
+  return(rc);
+}
+// ALT
+
+
 BOOL PSprocessTags(FILE *ifl, TTFDATA *pttfdt, FONTMETRICS *pFM, AFMData *pAD)
 {
   BOOL   rc;
@@ -1380,6 +1450,7 @@
         if (PFAfl != (FILE *)NULL)
         {
           /* convert file type to "PFM" */
+          /* (This does not actually seem to be used --ALT) */
           len = strlen(targetFile);
           targetFile[len-3] = 'P';
           targetFile[len-2] = 'F';
@@ -1516,4 +1587,330 @@
   return(valid);
 }
 
+// ALT
+/*****************************************************************************\
+**
+** Populate the AFMData structure (required for defining the font resources)
+** with information from a TrueType font.  This is basically a stripped-down
+** version of writePFA without the file output.
+**
+\*****************************************************************************/
+BOOL TTFPopulatePFA(FILE *ifl, TTFDATA *pttfdt, AFMData *pAD)
+{
+  USHORT        lp;
+  USHORT        lp2;
+  PSTTFHDR      ttfh;
+  long          tl;
+  BOOL          rc;
+  USHORT        *pCMap = NULL;
+  USHORT        width;
+  USHORT        lpmx;
+  USHORT        *start;
+  USHORT        *end;
+  USHORT        *delta;
+  USHORT        *off;
+  CMAPFMT4HDR   *pdt;
+  char          *PSname;
+  UCHAR         *pc;
+  USHORT        s;
+  USHORT        cp;
+
+  /* assume everything works */
+  rc = TRUE;
+
+  /* load the CMap, if error, return FALSE */
+  fseek(ifl, pttfdt->CMapOffset, SEEK_SET);
+  if (!PSgetCMapData(ifl, &pCMap, pAD->stdEncoding))
+    return(FALSE);
+
+  /* fill in all the pAD->CM[] with the default width */
+  width = getCharWidth(ifl, 0, pttfdt);
+  for (lp=0; lp<MAX_CHARS; lp++)
+  {
+    pAD->CM[lp].PSid = -1;
+    pAD->CM[lp].x = width;
+  }
+
+  /* if not a symbol font */
+  if (pAD->stdEncoding)
+  {
+    /* set array pointers (skip padding before start) */
+    pdt = (CMAPFMT4HDR *)pCMap;
+
+    lpmx = pdt->segCountX2 / 2;
+    end = (USHORT *)((UCHAR *)pdt + sizeof(CMAPFMT4HDR));
+    start = &end[lpmx+1];
+    delta = &start[lpmx];
+    off = &delta[lpmx];
+
+    /* loop through all the characters */
+    for (lp=0; lp<lpmx-1; lp++)
+    {
+      if (off[lp] != 0)
+      {
+        s = lp + (off[lp] / 2);
+        for (lp2 = start[lp]; lp2 <= end[lp]; lp2++, s++)
+        {
+          tl = 0;
+          while ((Unicode2PSname[tl].unicode != lp2) &&
+                 (Unicode2PSname[tl].unicode != 0))
+          {
+            tl++;
+          }
+
+          if (Unicode2PSname[tl].unicode != 0)
+          {
+            /* set the character width in the FNS file */
+            PSname = Unicode2PSname[tl].name;
+            width = getCharWidth(ifl, off[s], pttfdt);
+            for (tl=0; StdMapping[tl].Name != NULL; tl++)
+            {
+              if (strcmp(StdMapping[tl].Name, PSname) == 0)
+              {
+                pAD->CM[StdMapping[tl].OSid].PSid = StdMapping[tl].PSid;
+                pAD->CM[StdMapping[tl].OSid].x = width;
+              }
+            }
+          }
+        }
+      }
+      else
+      {
+        s = delta[lp] + start[lp];
+        for (lp2 = start[lp]; lp2 <= end[lp]; lp2++, s++)
+        {
+          tl = 0;
+          while ((Unicode2PSname[tl].unicode != lp2) &&
+                 (Unicode2PSname[tl].unicode != 0))
+          {
+            tl++;
+          }
 
+          if (Unicode2PSname[tl].unicode != 0)
+          {
+            /* set the character width in the FNS file */
+            PSname = Unicode2PSname[tl].name;
+            width = getCharWidth(ifl, s, pttfdt);
+            for (tl=0; StdMapping[tl].Name != NULL; tl++)
+            {
+              if (strcmp(StdMapping[tl].Name, PSname) == 0)
+              {
+                pAD->CM[StdMapping[tl].OSid].PSid = StdMapping[tl].PSid;
+                pAD->CM[StdMapping[tl].OSid].x = width;
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+  else
+  {
+    /* if format 4 header */
+    pdt = (CMAPFMT4HDR *)pCMap;
+    if (pdt->format == 4)
+    {
+      /* set array pointers (skip padding before start) */
+      lpmx = pdt->segCountX2 / 2;
+      end = (USHORT *)((UCHAR *)pdt + sizeof(CMAPFMT4HDR));
+      start = &end[lpmx+1];
+      delta = &start[lpmx];
+      off = &delta[lpmx];
+
+      /* loop through all the characters */
+      for (lp=0; lp < lpmx-1; lp++)
+      {
+        if (off[lp] != 0)
+        {
+          s = lp + (off[lp] / 2);
+          for (lp2 = start[lp]; lp2<=end[lp]; lp2++, s++)
+          {
+            if ((lp2 & 0x0FF00) == (USHORT)0x0F000)
+            {
+              cp = (USHORT)(lp2 & 0x0FF);
+
+              /* set the character width in the FNS file */
+              pAD->CM[lp].PSid = lp;
+              pAD->CM[lp].x = getCharWidth(ifl, off[s], pttfdt);
+            }
+          }
+        }
+        else
+        {
+          s = delta[lp] + start[lp];
+          for (lp2 = start[lp]; lp2 <= end[lp]; lp2++, s++)
+          {
+            if ((lp2 & 0x0FF00) == (USHORT)0x0F000)
+            {
+              cp = (USHORT)(lp2 & 0x0FF);
+
+              /* set the character width in the FNS file */
+              pAD->CM[lp].PSid = lp;
+              pAD->CM[lp].x = getCharWidth(ifl, s, pttfdt);
+            }
+          }
+        }
+      }
+    }
+    else
+    {
+      /* skip past header and format 0 is a byte array of 256 entries */
+      pc = (UCHAR *)pCMap + sizeof(CMAPDATAHDR);
+
+      /* get number of entries in table */
+      pdt->length -= sizeof(CMAPDATAHDR);
+      if (pdt->length > 256)
+        pdt->length = 256;
+
+      for (lp = 0; lp < pdt->length; lp++)
+      {
+        if (pc[lp] != 0)
+        {
+          /* set the character width in the FNS file */
+          pAD->CM[lp].PSid = lp;
+          pAD->CM[lp].x = getCharWidth(ifl, (USHORT)pc[lp], pttfdt);
+        }
+      }
+    }
+  }
+
+  /* free the CMap data that was allocated */
+  if (pCMap != NULL)
+    free(pCMap);
+
+  /* fill in header */
+  PSfillTTFheader(&ttfh, pttfdt);
+
+  return(rc);
+}
+
+#ifdef OPENTYPE_SUPPORT
+/*****************************************************************************\
+**
+** This is modified version of PSProcessTags which can be used for OpenType/CFF
+** fonts.  Specifically, it does not check for the TTF-specific tables which a
+** CFF font would not contain (and it checks for the CFF table instead).
+**
+\*****************************************************************************/
+
+BOOL PSprocessCFFTags(FILE *ifl, TTFDATA *pttfdt, FONTMETRICS *pFM, AFMData *pAD)
+{
+  BOOL   rc;
+  long   idx;
+
+  rc = TRUE;
+  pttfdt->fndtags = 0;
+
+  idx = getTagIndex(pttfdt, TT_OS_2_TAG);
+  if (idx >= 0)
+  {
+    pttfdt->fndtags |= FOUND_OS_2_TAG;
+    rc = PSprocessOS2Tag(ifl, &pttfdt->te[idx], pFM);
+  }
+  else
+    rc = FALSE;
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_MAXP_TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_MAXP_TAG;
+      rc = PSprocessMAXPTag(ifl, pttfdt, &pttfdt->te[idx]);
+    }
+    else
+      rc = FALSE;
+  }
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_CMAP_TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_CMAP_TAG;
+      rc = PSprocessCMAPTag(ifl, pttfdt, &pttfdt->te[idx], pFM, pAD);
+    }
+    else
+      rc = FALSE;
+  }
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_HEAD_TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_HEAD_TAG;
+      rc = PSprocessHEADTag(ifl, pttfdt, &pttfdt->te[idx], pFM);
+    }
+    else
+      rc = FALSE;
+  }
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_NAME_TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_NAME_TAG;
+      rc = PSprocessNAMETag(ifl, &pttfdt->te[idx], pFM, pAD->FontName, pAD->FontName);
+    }
+    else
+      rc = FALSE;
+  }
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_POST_TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_POST_TAG;
+      rc = PSprocessPOSTTag(ifl, pttfdt, &pttfdt->te[idx], pFM);
+      if ( rc )
+      {
+        //PSprocessPOSTTagForGlyphNames(ifl, &pttfdt->te[idx], pAD->FontName);
+      }
+    }
+    else
+      rc = FALSE;
+  }
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_CFF__TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_CFF__TAG;
+    }
+    else
+      rc = FALSE;
+  }
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_HHEA_TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_HHEA_TAG;
+      rc = PSprocessHHEATag(ifl, pttfdt, &pttfdt->te[idx], pFM);
+    }
+    else
+      rc = FALSE;
+  }
+
+  if (rc)
+  {
+    idx = getTagIndex(pttfdt, TT_HMTX_TAG);
+    if (idx >= 0)
+    {
+      pttfdt->fndtags |= FOUND_HMTX_TAG;
+      pttfdt->HMtxOffset = pttfdt->te[idx].offset;
+    }
+    else
+      rc = FALSE;
+  }
+
+  return(rc);
+}
+
+#endif
+// ALT
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/fonts.c src\osdd\pscript\psprint/fonts.c
--- src\osdd\pscript\post32/fonts.c	Tue Nov 11 18:10:14 2003
+++ src\osdd\pscript\psprint/fonts.c	Tue Dec  7 18:54:56 2010
@@ -80,6 +80,8 @@
 #define  INCL_GENPLIB_FONTMGR
 #include <genplib.h>
 
+#include <stdio.h>
+
 #ifdef DEBUG
 //#define  TESTING 1
 #endif
@@ -3759,7 +3761,11 @@
   // Write out section header
   if ( pMRCB->lCount )
   {
+#if 0 //Paul Smedley 2009-03-22
     PrintChannel( pddc,"%%%%DocumentSuppliedResources:\n" );
+#else
+    PrintChannel( pddc,"%%%%DocumentSuppliedFonts:\n" );
+#endif
   }
 
   // If the no_free flag is off then free blocks as processed
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/inc/package.h src\osdd\pscript\psprint/inc/package.h
--- src\osdd\pscript\post32/inc/package.h	Tue Nov 11 18:12:48 2003
+++ src\osdd\pscript\psprint/inc/package.h	Thu Dec 16 19:58:22 2010
@@ -63,7 +63,7 @@
 // Various signatures we that are out there
 //
 
-#define PAKSIGNATURE_DEVPACK_V1   "IBM DDPAK V1.0"
+#define PAKSIGNATURE_DEVPACK_V1   "IBM DDPAK V1.2"      // ALT_CUPS
 #define PAKSIGNATURE_FONTPACK_V1  "IBM FONTS V1.0"
 
 //
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/inc/ppdialog.h src\osdd\pscript\psprint/inc/ppdialog.h
--- src\osdd\pscript\post32/inc/ppdialog.h	Tue Nov 11 18:12:50 2003
+++ src\osdd\pscript\psprint/inc/ppdialog.h	Fri Dec  5 20:47:12 2014
@@ -630,7 +630,9 @@
   **  Screen frequencly in cells per inch multiplied by 100
   */
   LONG lScrFreq;
+
   SHORT fIsColorDevice;       /* whether device supports colour or not       */
+
   /*
   **  whether device supports independent file system or not
   */
@@ -669,6 +671,8 @@
   SHORT ofsDuplexNoTumble;   /* string to turn on duplex                    */
   SHORT ofsDuplexTumble;     /* string to turn on duplex/tumble             */
   SHORT ofsPCFileName;                                 
+
+  SHORT fTTSupport;          /* printer has TrueType support -- ALT_CUPS    */
 } PPD1;
 
 typedef struct _PPD2
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/inc/prdptypt.h src\osdd\pscript\psprint/inc/prdptypt.h
--- src\osdd\pscript\post32/inc/prdptypt.h	Tue Nov 11 18:12:52 2003
+++ src\osdd\pscript\psprint/inc/prdptypt.h	Mon Aug 19 15:20:40 2013
@@ -200,6 +200,7 @@
     BOOL    bLoaded ;           /* if soft, already loaded?                */
       #define  LOCKED        0x80
       #define  DYNFNT        0x40
+      #define  CFFDATA       0x2000     // ALT_PSPRINT
     PSZ     pszOFM ;            /* file name, with path; 0L for hw font    */
     PSZ     pszPFB ;            /* file name, with path; 0L for hw font    */
     ULONG   ulFlags;            // Set of general flags for fonts
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/jpdlg.c src\osdd\pscript\psprint/jpdlg.c
--- src\osdd\pscript\post32/jpdlg.c	Tue Nov 11 18:10:18 2003
+++ src\osdd\pscript\psprint/jpdlg.c	Tue Jan 20 23:53:58 2015
@@ -1981,6 +1981,19 @@
 
             break;
 
+       // ALT 20150120
+       case JPE_COLORCHECK:
+            if (SHORT2FROMMP( mp1 ) == BN_CLICKED )
+            {
+              iNewIcon = (SHORT) WinSendDlgItemMsg( hDlg, JPE_COLORCHECK,
+                                                    BM_QUERYCHECK,
+                                                    (MPARAM) 0, (MPARAM) 0 ) ?
+                         ICON_MONOCHROME : ICON_COLOR;
+              UpdateIcon( hDlg, pJPInfo->hDlg, JPSB_MONOCHROME, iNewIcon );
+            }
+            break;
+       // ALT 20150120
+
        /*
        ** If this message is received in this procedure, then the color model
        ** is not a UI.
@@ -2189,6 +2202,11 @@
         /*
         ** This flag is set if "*ColorModel" is not in the PPD.  This tells
         ** the driver that the color combo box is not a UI control.
+        **
+        **** {Surely the above is backwards: IS_COLOR_UI means ColorModel
+        ****  IS a UIItem... right?  The code here and elsewhere certainly
+        ****  seems to bear that out. --ALT}
+        ****
         */
         pJPInfo->usFlags |= IS_COLOR_UI;
 
@@ -2196,12 +2214,23 @@
         {
           InitializeUIControl( hDlg, pJPInfo, UINAME_COLORMODEL,
                                JPE_COLOR_LIST, JPE_COLOR_GROUP );
+          // ALT 20150120
+          WinShowWindow( WinWindowFromID( hDlg, JPE_COLORCHECK ), TRUE );
         }
         else
         {
           WinSendDlgItemMsg( hDlg, JPE_COLOR_LIST, UCM_UNDO, (MPARAM) 0,
                              (MPARAM) 0 );
         }
+
+        // ALT 20150120
+        WinSendDlgItemMsg( hDlg, JPE_COLORCHECK, BM_SETCHECK,
+                           MPFROMSHORT( pCNFData->jobProperties.fIsColorDevice? 0: 1 ),
+                           (MPARAM) 0 );
+        UpdateIcon( hDlg, pJPInfo->hDlg, JPSB_MONOCHROME,
+                    pCNFData->jobProperties.fIsColorDevice? ICON_COLOR: ICON_MONOCHROME );
+        // ALT 20150120
+
       }
     }
     else
@@ -2269,6 +2298,11 @@
   INT  iValue;
   UINT uiRC = PMERR_OK;
   PCNFDATA   pCNFData = pJPInfo->pCNFData;
+#if 1
+  PUI_BLOCK  pUIBlock;
+  INT        iIndexFound;
+  BOOL       fClrModel;
+#endif
 
   /*
   ** Query the current zero-based offset position of the slider from the
@@ -2316,6 +2350,31 @@
   /*
   ** Store the color option.
   */
+
+#if 1       // ALT 20141203
+  fClrModel = FALSE;
+  if (pJPInfo->pdesPPD->desItems.fIsColorDevice == TRUE)
+  {
+    pUIBlock = QueryBlockFromKeyword( &pJPInfo->pdesPPD->stUIList,
+                                      pJPInfo->pItemsBuff, UINAME_COLORMODEL,
+                                      &iIndexFound );
+    if ((pUIBlock != NULL) && (iIndexFound > -1)) {
+       // Printer supports ColorModel
+       fClrModel = TRUE;
+    }
+  }
+
+  if (fClrModel == TRUE) {
+     // Let the device assume all responsibility for conversion
+//   pJPInfo->pCNFData->jobProperties.fIsColorDevice = TRUE;
+     pJPInfo->pCNFData->jobProperties.fIsColorDevice =
+        (SHORT) WinSendDlgItemMsg( hDlg, JPE_COLORCHECK, BM_QUERYCHECK,
+                                   (MPARAM) 0, (MPARAM) 0 ) ? FALSE : TRUE;
+  }
+  else
+#endif      // ALT 20141203
+  {         // ALT 20141203
+
   iValue = (INT) WinSendDlgItemMsg( hDlg, JPE_COLOR_LIST,
                                     LM_QUERYSELECTION,
                                     MPFROMSHORT( LIT_FIRST ), (MPARAM) 0 );
@@ -2329,6 +2388,7 @@
     pJPInfo->pCNFData->jobProperties.fIsColorDevice = FALSE;
   }
 
+  }         // ALT 20141203
   return( uiRC );
 }
 /*---------------------------------------------------------------------------*\
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/BUGS src\osdd\pscript\psprint/pin/BUGS
--- src\osdd\pscript\post32/pin/BUGS	Thu Jan  1 00:00:00 1970
+++ src\osdd\pscript\psprint/pin/BUGS	Mon Dec 27 16:24:44 2010
@@ -0,0 +1,9 @@
+BUGS & LIMITATIONS
+
+- ofsDefimagearea (*DefaultImageableArea) and ofsDefpaperdim 
+  (*DefaultPaperDimension) are always undefined (set to -1)
+
+- Order information for *ParamCustomPageSize is not stored.
+
+- *ParamCustomPageSize items for offset and orientation are not stored.
+
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/conv_ppd.c src\osdd\pscript\psprint/pin/conv_ppd.c
--- src\osdd\pscript\post32/pin/conv_ppd.c	Tue Nov 11 18:10:50 2003
+++ src\osdd\pscript\psprint/pin/conv_ppd.c	Sun May 25 23:42:58 2014
@@ -72,6 +72,7 @@
  *
  *              Signature has got the following structure:
  *              Identifying name               40 bytes,
+ *              CRC (not used)                  4 bytes,
  *              Total no of entries in dir      2 bytes,
  *              Present no of entries in dir    2 bytes,
  *              free                            4 bytes.
@@ -80,6 +81,8 @@
  *              following structure:
  *              Printer name                   40 bytes,
  *              Offset of printer segment       4 bytes,
+ *              Size of printer segment         4 bytes,
+ *              Flags                           4 bytes,
  *              free                            4 bytes.
  *
  *              Each printer information segment has got the structure
@@ -101,7 +104,12 @@
 #include <stdlib.h>
 #include <string.h>
 #include <ctype.h>
-#include <builtin.h>
+#ifndef __KLIBC__
+  #include <builtin.h>
+#else
+  typedef INT      *PINT;
+  #define strcmpi strcmp
+#endif
 
 //#include <genplib.h>
 #include "ppd2bin.h"
@@ -114,6 +122,8 @@
 #define  COMPRESS TRUE
 #define  NOCOMPRESS FALSE
 
+#define  BLBUFSIZE              12288   // ALT_CUPS, taken from bvl
+
 #define  CSTR_NORMAL             0     
 #define  CSTR_INCLUDE_SLASH      1     
 #define  CSTR_HEX2CHAR           2     
@@ -163,7 +173,8 @@
 } UIFileGroup;
 
 char acDefFont[] = "Courier";
-int cbBuffout = 0;                     /* number of bytes filled in output
+// ALT 20140524 changed from int to long
+long cbBuffout = 0;                     /* number of bytes filled in output
                                           buffer                             */
 DESPPD desPpd;                         /* printer descriptor segments        */
 
@@ -766,6 +777,8 @@
     /*
     ** copies the string delimited by a blank with ist byte as length.
     ** Strings are not null terminated
+    ** (NOTE: This does not appear to be true anymore; CopyString outputs
+    ** null-terminated strings nowadays, and the length is omitted. --ALT)
     */
     if (strncmp( pbPrBuffer + i, "Unknown", 7 ))
     {
@@ -1208,6 +1221,29 @@
     }
   }
 
+// ALT_CUPS
+#if 0
+/*
+  // If still not found look for the first "StpQuality" item (used by CUPS)
+  if ( desPpd.desItems.iResDpi == 0 )
+  {
+    fbseek( &fbIn, (long)0, SEEK_SET );
+    if (ScanParam( szSearch[CupsRes], pbPrBuffer ))
+    {
+      char *phwres;
+      i = MovePast( pbPrBuffer, ':' );
+      if (( phwres = strstr( pbPrBuffer, "/HWResolution" )) != NULL )
+      {
+        i = MovePast( phwres, '[' );
+        desPpd.desItems.iResDpi = (short) atoi( phwres + i );
+        //printf("Using *StpQuality for default resolution: %d.\n", desPpd.desItems.iResDpi );
+      }
+    }
+  }
+*/
+#endif
+// ALT_CUPS
+
   // beef up resolution
   if (desPpd.desItems.iResDpi == 0)
   {
@@ -1264,6 +1300,36 @@
     desPpd.desItems.fIsColorDevice = NONE;
   }
 
+  // ALT_CUPS
+  /*
+  ** To read the flag that indicates whether the device supports
+  ** TrueType (a.k.a. Type 42) or not.
+  */
+  fbseek( &fbIn, (long)0, SEEK_SET );
+
+  if (ScanParam( szSearch[TTRasterizer], pbPrBuffer ))
+  {
+    /*
+    ** skip the " character
+    */
+    i = MovePast( pbPrBuffer, ':' );
+    i += SkipBlank( pbPrBuffer + i );
+
+    if (!strnicmp("Type42", pbPrBuffer+i, 6))
+    {
+      desPpd.desItems.fTTSupport = TRUE;
+    }
+    else
+    {
+      desPpd.desItems.fTTSupport = NONE;
+    }
+  }
+  else
+  {
+    desPpd.desItems.fTTSupport = NONE;
+  }
+  // ALT_CUPS
+
   /*
   ** To read the True or False value indicating whether the Postscript
   ** device has a built in file system.
@@ -1375,10 +1441,10 @@
          px  = strstr(pbPrBuffer,"points") + strlen("points");
          i = SkipBlank(px);
          px += i;
-         desPpd.desPage.iCustomPageSizeMinHeight = atoi(px);
+         desPpd.desPage.iCustomPageSizeMinHeight = (SHORT)atoi(px);     // ALT_CUPS
          i = MovePast( px, ' ' );
          px += i;
-         desPpd.desPage.iCustomPageSizeMaxHeight = atoi(px);
+         desPpd.desPage.iCustomPageSizeMaxHeight = (SHORT)atoi(px);     // ALT_CUPS
        }
      }
      if(desPpd.desPage.iCustomPageSizeMinWidth  != NOT_SELECTED &&
@@ -1451,6 +1517,7 @@
   */
   if (desPpd.desFonts.ofsDeffont == -1)
   {
+#if 0
     /*
     ** Copy the default font (no ending null)
     */
@@ -1462,6 +1529,17 @@
     {
       *(pbItemsBuffer + cbBuffout) = acDefFont[i];
     }
+#else
+// ALT_CUPS
+    /*
+    ** Strings ARE null-terminated nowadays, so use the following in order to
+    ** prevent prda_DefaultFontIndex from failing (probably leading to a trap).
+    */
+    desPpd.desFonts.ofsDeffont = cbBuffout;
+    i = CopyString( pbItemsBuffer + cbBuffout, acDefFont, 80, CSTR_NORMAL );
+    cbBuffout += i;
+// ALT_CUPS
+#endif
   }
 
   /*
@@ -1490,7 +1568,7 @@
   }
   else
   {
-    desPpd.desOutbins.fIsDefoutorder = REVERSE;
+    desPpd.desOutbins.fIsDefoutorder = NORMAL;      // ALT change from REVERSE
   }
 
   /*
@@ -1515,11 +1593,12 @@
     /*
     ** skip the " character
     */
-    i = MovePast( pbPrBuffer, '"' );
+    // ALT  Change '"' to ':' to prevent skipping right past "" pair...
+    // ALT  CopyInQuote (below) should take care of the quotes anyway.
+    i = MovePast( pbPrBuffer, ':' );
 
     /*
-    ** copies the string delimited by a blank or quote with ist byte
-    ** as length. Strings are not null terminated
+    ** copies the string delimited by a blank or quote
     */
     j = CopyInQuote( pbItemsBuffer+cbBuffout, pbPrBuffer+i, FALSE,
                      COMPRESS );
@@ -1766,7 +1845,6 @@
   {
     for (j = 0 ; j < 32 ; j++)
     {
-      
       if (isspace( pbPrBuffer[ j ] ) || pbPrBuffer[ j ] == ':' ||
           pbPrBuffer[ j ] == 0)
       {
@@ -1775,17 +1853,30 @@
       }
     }
 
-    if(j)  // just checking...
+    if(j && (j < 32) && ((cbBuffout + j + 1) < (PRBUFSZ * 24))) // ALT 20140524
     {
        strcpy(pbItemsBuffer + cbBuffout,pbPrBuffer);
-       cbBuffout += strlen(pbPrBuffer) + 1; // terminator too
+       cbBuffout += j + 1;      // ALT 20140524 string length incl terminator
 
        k++;
     }
   }
   desPpd.desFonts.iFonts = k;
+
+  // ALT Make sure the fonts offset isn't just pointing into oblivion...
+  if ( desPpd.desFonts.ofsFontnames == cbBuffout )
+     desPpd.desFonts.ofsFontnames = -1;
+  // ALT
+
   ProcessFormTable();
 
+  // ALT Make sure the forms offsets aren't pointing into oblivion either
+  if ( desPpd.desForms.ofsFormTable == cbBuffout )
+     desPpd.desForms.ofsFormTable = -1;
+  if ( desPpd.desForms.ofsFormIndex == cbBuffout )
+     desPpd.desForms.ofsFormIndex = -1;
+  // ALT
+
   fbclose( &fbIn );
 //desPpd.desItems.iSizeBuffer = cbBuffout;
   desPpd.desItems.iSizeBuffer = cbBuffout + iShrinkage;
@@ -2039,14 +2130,16 @@
           pUIBlock1->ofsUIName += 3;
         }
 
-        
+#if 0       // ALT_CUPS  prevent UI_ORDER_ANYSETUP from getting replaced
         if (pUIBlock1->usUILocation == 0)
         {
           pUIBlock1->usUILocation = UI_ORDER_PROLOGSETUP;
         }
+#endif      // ALT_CUPS
       }
 
-      DosAllocMem( (PPVOID) &pTemp, 4096,
+
+      DosAllocMem( (PPVOID) &pTemp, BLBUFSIZE,              // ALT_CUPS
                    PAG_READ | PAG_WRITE | PAG_COMMIT );
       ofsTemp = 0;
 
@@ -2107,7 +2200,7 @@
   PCHAR pStorage = pbItemsBuffer + cbBuffout;
   PCHAR pLine = pbPrBuffer + uiStrLen;
 #endif
-  PCHAR pCompare;
+  PCHAR pCompare = NULL;
   CHAR  cGroupType;
   PCHAR pKeyword;                                    
   
@@ -2332,6 +2425,12 @@
       {
         pUIBlock->usUILocation = UI_ORDER_JCLSETUP;
       }
+// ALT_CUPS
+      else if (!strncmp( pbPrBuffer + uiStrLen, "AnySetup", 8 ))
+      {
+        pUIBlock->usUILocation = UI_ORDER_ANYSETUP;
+      }
+// ALT_CUPS
       else
       {
         pUIBlock->usUILocation = UI_ORDER_PROLOGSETUP;
@@ -2339,7 +2438,7 @@
     }
     else if (!strncmp( pbPrBuffer + uiStrLen, "*CloseUI", 8 )     ||
              !strncmp( pbPrBuffer + uiStrLen, "*JCLCloseUI", 11 ) ||
-             pUIBlock->usNumOfEntries >= 30                        )  
+             pUIBlock->usNumOfEntries >= 100                        )   // ALT_CUPS (inc. from 30 as per bvl)
     {
       break;
     }
@@ -2358,6 +2457,24 @@
       
       /*      */                                                                         
       bSkipEntry = FALSE;                                                        
+
+      // ALT_CUPS, from bvl
+      // bvl: if we are in resolution, we need to check the whole string for "" this is invalid
+
+      if (pCompare && strcmpi(pCompare, "Resolution")==0)
+      {
+        ULONG uiResStr;
+        // we are in resolution processing
+        uiResStr = uiStrLen + MovePast( pbPrBuffer + uiStrLen, ':' );
+        uiResStr += SkipBlank( pbPrBuffer + uiResStr );
+        if(strnicmp(pbPrBuffer+uiResStr,"\"\"",2)==0)
+        {
+            // we found a empty resolution string so skip this one
+            bSkipEntry = TRUE;
+        }
+      }
+      // ALT_CUPS
+
       if ( bInputSlot )                                                          
       {                                                                          
         if ( *pusFlags & PUIB_CREATE_MEDIA )                                     
@@ -3239,12 +3356,12 @@
    /*
    */
    memset( pUIList, 0, sizeof( UI_LIST ) );
-   DosAllocMem( (PPVOID) &pUIList->pBlockList, 4096,
+   DosAllocMem( (PPVOID) &pUIList->pBlockList, BLBUFSIZE,       // ALT_CUPS
                 PAG_READ | PAG_WRITE | PAG_COMMIT );
-   memset( pUIList->pBlockList, 0, 4096 );
+   memset( pUIList->pBlockList, 0, BLBUFSIZE );                 // ALT_CUPS
  
    memset( &desPpd.stUICList, 0, sizeof( UIC_LIST ) );
-   DosAllocMem( (PPVOID) &desPpd.stUICList.puicBlockList, 4096,
+   DosAllocMem( (PPVOID) &desPpd.stUICList.puicBlockList, BLBUFSIZE,    // ALT_CUPS
                 PAG_READ | PAG_WRITE | PAG_COMMIT );
  
    
@@ -3348,7 +3465,7 @@
       {
         fwrite( pUIList->pBlockList, 1, desPpd.stUIList.usBlockListSize,
                 fhOut );
-        memset( pUIList->pBlockList, 0, 4096 );
+        memset( pUIList->pBlockList, 0, BLBUFSIZE );        // ALT_CUPS
       }
       pUIList->usNumOfBlocks = 0;
       pUIList->usBlockListSize = 0;
@@ -3357,7 +3474,7 @@
       {
         fwrite( desPpd.stUICList.puicBlockList, 1,
                 desPpd.stUICList.usNumOfUICs * sizeof( UIC_BLOCK ), fhOut );
-        memset( desPpd.stUICList.puicBlockList, 0, 4096 );
+        memset( desPpd.stUICList.puicBlockList, 0, BLBUFSIZE );              // ALT_CUPS
       }
 
       printf(".");
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/driverea.c src\osdd\pscript\psprint/pin/driverea.c
--- src\osdd\pscript\post32/pin/driverea.c	Tue Nov 11 18:10:50 2003
+++ src\osdd\pscript\psprint/pin/driverea.c	Sun Nov 21 13:23:40 2010
@@ -299,6 +299,10 @@
 //    changes for directory.ppb reading
 //    
 
+#define  VERSION_CUPS42 "V1.2.0"
+//    changes for Type 42 support
+//
+
 
 int DriverEA_Init(PSZ pszFile)
 {
@@ -357,7 +361,7 @@
       goto EXIT_FAIL;
    }
 
-   if(!strcmp(pszBuf,VERSION_DDPAK15))
+   if(!strcmp(pszBuf,VERSION_CUPS42))
       ;
    else 
       goto EXIT_FAIL;
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/ipinmain.c src\osdd\pscript\psprint/pin/ipinmain.c
--- src\osdd\pscript\post32/pin/ipinmain.c	Tue Nov 11 18:10:50 2003
+++ src\osdd\pscript\psprint/pin/ipinmain.c	Wed Nov 24 17:26:58 2010
@@ -52,6 +52,10 @@
 #include "afm2pak.h"
 #include "ppd2ppb.h"
 
+#ifdef __KLIBC__
+    #define strcmpi strcmp
+#endif
+
 //
 //
 //
@@ -158,8 +162,10 @@
 {
    int rc = 1;  // NMAKE takes nonzero return value for error
 
-   printf("PostScript resource packaging utility version 1.00\n");
+   // Increment version to 1.20  -- ALT_CUPS  2010-11-20
+   printf("PostScript resource packaging utility version 1.20\n");
    printf("Copyright (c) IBM Corp 2000. All rights reserved.\n");
+   printf("Copyright (c) netlabs.org 2007,2010. All rights reserved.\n\n");
    if(ParseConfig(argc,argv))
    {
       switch(iAction)
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/package.h src\osdd\pscript\psprint/pin/package.h
--- src\osdd\pscript\post32/pin/package.h	Tue Nov 11 18:12:56 2003
+++ src\osdd\pscript\psprint/pin/package.h	Thu Dec 16 19:58:12 2010
@@ -62,8 +62,7 @@
 //
 // Various signatures we that are out there
 //
-
-#define PAKSIGNATURE_DEVPACK_V1   "IBM DDPAK V1.0"
+#define PAKSIGNATURE_DEVPACK_V1   "IBM DDPAK V1.2"  // ALT_CUPS
 #define PAKSIGNATURE_FONTPACK_V1  "IBM FONTS V1.0"
 
 //
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/pakt.cmd src\osdd\pscript\psprint/pin/pakt.cmd
--- src\osdd\pscript\post32/pin/pakt.cmd	Thu Jan  1 00:00:00 1970
+++ src\osdd\pscript\psprint/pin/pakt.cmd	Tue Dec 28 20:28:44 2010
@@ -0,0 +1,30 @@
+/* PAKT.CMD  Build PAKTOOL executable */
+ARG dr_type
+
+SELECT
+    WHEN dr_type == '1' | LEFT( dr_type, 1 ) == 'P' THEN DO
+        level = 1
+        exename = 'ppaktool'
+    END
+    WHEN dr_type == '2' | LEFT( dr_type, 1 ) == 'E' THEN DO
+        level = 2
+        exename = 'epaktool'
+    END
+    WHEN dr_type == '3' | LEFT( dr_type, 1 ) == 'I' THEN DO
+        level = 3
+        exename = 'ipaktool'
+    END
+    OTHERWISE DO
+        SAY 'To build PAKTOOL executable, use syntax:'
+        SAY '  PAKT <opt>'
+        SAY 'where <opt> indicates which driver PAKTOOL should be compatible with:'
+        SAY '1  PSPRINT'
+        SAY '2  ECUPS or DDK mainline PSCRIPT driver'
+        SAY '3  IBM post-DDK PSCRIPT driver (e.g. 30.822 or 30.827)'
+        RETURN 0
+    END
+END
+
+'icc /Sp1 /Ss /DPSDRIVER='level' /Fe'exename' paktool.c'
+
+RETURN rc
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/paktool.c src\osdd\pscript\psprint/pin/paktool.c
--- src\osdd\pscript\post32/pin/paktool.c	Thu Jan  1 00:00:00 1970
+++ src\osdd\pscript\psprint/pin/paktool.c	Fri May 30 11:59:10 2014
@@ -0,0 +1,1578 @@
+/*
+ * Syntax: ppaktool <pakfile> [<action>]
+ *
+ * Possible values for <action>:
+ *    l              List printers defined in <pakfile>
+ *    v "<printer>"  View data for <printer>, formatted by structure
+ *    r "<printer>"  View data for <printer>, formatted for readability
+ *    p "<printer>"  Generate a PIN-compatible PPD file for <printer> (to stdout)
+ *    d "<printer>"  Dump the raw (binary) data for <printer> (to stdout)
+ *    x "<printer>"  Dump the hexadecimal (binary) data for <printer>
+ *    b "<printer>"  Dump the (binary) data for <printer> in prettified hex/raw comparison
+ */
+
+#define INCL_DOSFILEMGR
+#define INCL_DOSERRORS
+#include <os2.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include "pt_struct.h"
+#include "package.h"
+#include "ppdtable.h"
+
+// Overrides signature definition in package.h
+#if PSDRIVER == 1
+#define PAKSIGNATURE_DEVPACK_V1   "IBM DDPAK V1.2"  // ALT_CUPS
+#else
+#define PAKSIGNATURE_DEVPACK_V1   "IBM DDPAK V1.0"  // ALT_CUPS
+#endif
+
+// These correspond to the program execution modes (according to cmd-line)
+#define ACTION_LIST  1      // list printers
+#define ACTION_VIEW  2      // view structured data
+#define ACTION_DUMP  3      // dump raw data
+#define ACTION_HEX   4      // dump hex data
+#define ACTION_BOTH  5      // dump both hex & raw data
+#define ACTION_READ  6      // show readable data
+#define ACTION_PPD   7      // generate PPD file
+
+// Values for the data-format flag passed to ShowPrinterData()
+#define DEV_FMT_DATA 1      // formatted (structured) data
+#define DEV_RAW_DATA 2      // raw data dump
+#define DEV_HEX_DATA 3      // hex data dump
+#define DEV_BIN_DATA 4      // combined binary (raw/hex) data dump
+#define DEV_TXT_DATA 5      // readable text
+#define DEV_PPD_DATA 6      // PPD output
+
+// Convert an offset into the data buffer into a pointer to string.  Note:
+// i is the offset value; p is the pointer to the information segment buffer.
+#define OFFSET_TO_PSZ(i, p)    ((i > 0)? (PSZ)(p+i): "(none)")
+
+// Some useful macros for formatted output of offset values
+#define OFFSET_FORMAT( i )     ((i <= 0)? "  %7d": "%#9x")
+
+// Replace certain undisplayable raw-byte values
+#define DISPLAYABLE_CHAR( c )  ( c == 0 ? ' ' : ( c < 32 ? 127: c ))
+
+
+ULONG  ListPrinters( PSZ pszPakFile );
+ULONG  ShowPrinterData( PSZ pszPakFile, PSZ pszPrinter, USHORT fsMode );
+void   ShowDeviceData( PAK_DEV_DIRENTRY pdd, PBYTE pBuf );
+void   ShowReadableData( PAK_DEV_DIRENTRY pdd, PBYTE pBuf );
+void   GeneratePPD( PBYTE pBuf );
+void   DumpBytes( PBYTE pBuf, ULONG cb, BOOL fHex );
+void   PrettyBytes( PBYTE pBuf, ULONG cb );
+PSZ    OffsetToCommand( SHORT sOff, PBYTE pIn, PBYTE pOut );
+USHORT DecompressString(PSZ pszBuffIn, PSZ pszBuffOut);
+
+#if PSDRIVER == 1
+#define TOOL_NAME "ppaktool"
+#elif PSDRIVER == 2
+#define TOOL_NAME "epaktool"
+#else
+#define TOOL_NAME "ipaktool"
+#endif
+
+/* ------------------------------------------------------------------------- */
+int main( int argc, char *argv[] )
+{
+    PSZ    pszPakFile = PAKNAME_AUXDEV_PACK,
+           pszArg     = NULL;
+    USHORT usAction   = ACTION_LIST;
+    APIRET rc = 0;
+
+    if ( argc > 1 ) {
+        pszPakFile = argv[1];
+        if ( argc > 2 ) {
+            strupr( argv[2] );
+            if ( *argv[2] == '/' || *argv[2] == '-') argv[2]++;
+            switch ( *argv[2] ) {
+                case 'L':  usAction = ACTION_LIST; break;
+                case 'V':  usAction = ACTION_VIEW; break;
+                case 'R':  usAction = ACTION_READ; break;
+                case 'D':  usAction = ACTION_DUMP; break;
+                case 'X':  usAction = ACTION_HEX;  break;
+                case 'B':  usAction = ACTION_BOTH; break;
+                case 'P':  usAction = ACTION_PPD;  break;
+            }
+            if ( argc > 3 ) pszArg = argv[3];
+        }
+    }
+    else {
+        printf("PostScript PAK Utility version 0.2\n");
+        printf("Syntax: %s <pakfile> [<action>]\n\n", TOOL_NAME );
+        printf("Supported actions:\n\n");
+        printf(" L              List printers in driver PAK file <pakfile> (default)\n\n");
+        printf(" P \"<printer>\"  Generate a PIN-compatible PPD listing for <printer>\n");
+        printf(" R \"<printer>\"  View data for <printer> in a form optimized for readability\n");
+        printf(" V \"<printer>\"  View data for <printer>, formatted by its internal structure\n\n");
+        printf(" B \"<printer>\"  Dump binary data for <printer> in combined (raw/hex) format\n");
+        printf(" D \"<printer>\"  Dump binary data for <printer> as raw bytes\n");
+        printf(" X \"<printer>\"  Dump binary data for <printer> as hexadecimal bytes\n\n");
+        printf("All output is to STDOUT.\n");
+        return 0;
+    }
+
+    switch ( usAction ) {
+        case ACTION_LIST : rc = ListPrinters( pszPakFile );                          break;
+        case ACTION_VIEW : rc = ShowPrinterData( pszPakFile, pszArg, DEV_FMT_DATA ); break;
+        case ACTION_READ : rc = ShowPrinterData( pszPakFile, pszArg, DEV_TXT_DATA ); break;
+        case ACTION_PPD  : rc = ShowPrinterData( pszPakFile, pszArg, DEV_PPD_DATA ); break;
+        case ACTION_DUMP : rc = ShowPrinterData( pszPakFile, pszArg, DEV_RAW_DATA ); break;
+        case ACTION_HEX  : rc = ShowPrinterData( pszPakFile, pszArg, DEV_HEX_DATA ); break;
+        case ACTION_BOTH : rc = ShowPrinterData( pszPakFile, pszArg, DEV_BIN_DATA ); break;
+    }
+
+    if ( rc ) printf("Error reading file (error %u)\n", rc );
+    return rc;
+}
+
+
+/* ------------------------------------------------------------------------- */
+ULONG ListPrinters( PSZ pszPakFile )
+{
+    HFILE            hf;
+    ULONG            ulResult;
+    SHORT            i;
+    PAKSIGNATURE     pak_sig;
+    PAK_DEV_DIRENTRY pak_dev;
+    APIRET           rc;
+
+    if (( rc = DosOpen( pszPakFile, &hf, &ulResult, 0, 0,
+                        OPEN_ACTION_FAIL_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS,
+                        OPEN_FLAGS_FAIL_ON_ERROR | OPEN_FLAGS_SEQUENTIAL |
+                        OPEN_SHARE_DENYNONE | OPEN_ACCESS_READONLY, NULL )) > 0 )
+    {
+        switch ( rc ) {
+            case 2: printf("The file \"pszPakFile\" was not found.\n");
+                    break;
+            case 3: printf("The specified path was not found.\n");
+                    break;
+            case 5: printf("Access denied.\n");
+                    break;
+        }
+        return rc;
+    }
+
+    rc = DosRead( hf, &pak_sig, sizeof( PAKSIGNATURE ), &ulResult );
+    if ( rc ) goto cleanup;
+    if (( ulResult < sizeof( PAKSIGNATURE )) ||
+        ( strcmp( pak_sig.szName, PAKSIGNATURE_DEVPACK_V1 ) != 0 ))
+    {
+        printf("Invalid PAK file signature!\n");
+        if ( ! strncmp( pak_sig.szName, PAKSIGNATURE_DEVPACK_V1, 9 )) {
+            printf(" - Expected signature: %s\n", PAKSIGNATURE_DEVPACK_V1 );
+            printf(" - Found signature:    %s\n", pak_sig.szName );
+            printf("This PAK file seems to have been created for a different printer driver.\n");
+        }
+        rc = ERROR_INVALID_DATA;
+        goto cleanup;
+    }
+
+    printf("%s\n==============\n", pak_sig.szName );
+    printf("%d printers defined:\n", pak_sig.iEntries );
+
+    for ( i = 0; i < pak_sig.iEntries; i++ ) {
+        rc = DosRead( hf, &pak_dev, sizeof( PAK_DEV_DIRENTRY ), &ulResult );
+        if ( rc || ulResult < sizeof( PAK_DEV_DIRENTRY )) goto cleanup;
+        printf(" - %s (offset 0x%X, %u bytes, flags=0x%X)\n",
+                pak_dev.szDeviceName, pak_dev.ulOffset, pak_dev.ulSize, pak_dev.ulFlags );
+    }
+
+cleanup:
+    DosClose( hf );
+    return rc;
+}
+
+
+/* ------------------------------------------------------------------------- */
+ULONG ShowPrinterData( PSZ pszPakFile, PSZ pszPrinter, USHORT fsMode )
+{
+    HFILE            hf;
+    ULONG            ulResult;
+    SHORT            i;
+    BOOL             fFound = FALSE;
+    PAKSIGNATURE     pak_sig;
+    PAK_DEV_DIRENTRY pak_dev;
+    PBYTE            pBuf;
+    APIRET           rc;
+
+    if (( rc = DosOpen( pszPakFile, &hf, &ulResult, 0, 0,
+                        OPEN_ACTION_FAIL_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS,
+                        OPEN_FLAGS_FAIL_ON_ERROR | OPEN_FLAGS_SEQUENTIAL |
+                        OPEN_SHARE_DENYNONE | OPEN_ACCESS_READONLY, NULL )) > 0 )
+    {
+        switch ( rc ) {
+            case 2: printf("The file \"pszPakFile\" was not found.\n");
+                    break;
+            case 3: printf("The specified path was not found.\n");
+                    break;
+            case 5: printf("Access denied.\n");
+                    break;
+        }
+        return rc;
+    }
+
+    rc = DosRead( hf, &pak_sig, sizeof( PAKSIGNATURE ), &ulResult );
+    if ( rc ) goto cleanup;
+    if (( ulResult < sizeof( PAKSIGNATURE )) ||
+        ( strcmp( pak_sig.szName, PAKSIGNATURE_DEVPACK_V1 ) != 0 ))
+    {
+        printf("Invalid PAK file signature!\n");
+        rc = ERROR_INVALID_DATA;
+        goto cleanup;
+    }
+
+    // If no printer name was requested, just grab the first one
+    if ( !pszPrinter ) {
+        rc = DosRead( hf, &pak_dev, sizeof( PAK_DEV_DIRENTRY ), &ulResult );
+        if ( rc || ulResult < sizeof( PAK_DEV_DIRENTRY )) goto cleanup;
+        fFound = TRUE;
+    }
+    // Otherwise, search the directory for the specified printer
+    else for ( i = 0; i < pak_sig.iEntries; i++ ) {
+        rc = DosRead( hf, &pak_dev, sizeof( PAK_DEV_DIRENTRY ), &ulResult );
+        if ( rc || ulResult < sizeof( PAK_DEV_DIRENTRY )) goto cleanup;
+        if ( stricmp( pak_dev.szDeviceName, pszPrinter ) == 0 ) {
+            fFound = TRUE;
+            break;
+        }
+    }
+    if ( !fFound ) {
+        printf("The requested printer was not found\n");
+        goto cleanup;
+    }
+
+    // Seek to the indicated offset for this printer's data
+    rc = DosSetFilePtr( hf, pak_dev.ulOffset, FILE_BEGIN, &ulResult );
+    if ( rc || ulResult != pak_dev.ulOffset ) goto cleanup;
+
+    // Read the data into a simple buffer
+    if (( pBuf = (PBYTE) malloc( pak_dev.ulSize )) == NULL ) {
+        printf("malloc() failed - out of memory?\n");
+        goto cleanup;
+    }
+    rc = DosRead( hf, pBuf, pak_dev.ulSize, &ulResult );
+    if ( rc || ulResult < pak_dev.ulSize ) {
+        printf("Error reading device data.\n");
+        free( pBuf );
+        goto cleanup;
+    }
+
+    // OK, we have the data... now output it in the manner requested.
+    switch ( fsMode ) {
+        case DEV_FMT_DATA: ShowDeviceData( pak_dev, pBuf );          break;
+        case DEV_TXT_DATA: ShowReadableData( pak_dev, pBuf );        break;
+        case DEV_PPD_DATA: GeneratePPD( pBuf );                      break;
+        case DEV_RAW_DATA: DumpBytes( pBuf, pak_dev.ulSize, FALSE ); break;
+        case DEV_HEX_DATA: DumpBytes( pBuf, pak_dev.ulSize, TRUE );  break;
+        case DEV_BIN_DATA: PrettyBytes( pBuf, pak_dev.ulSize );      break;
+    }
+
+    free( pBuf );
+
+cleanup:
+    DosClose( hf );
+    return rc;
+}
+
+
+/* ------------------------------------------------------------------------- *
+ * DumpBytes                                                                 *
+ *                                                                           *
+ * Dump the contents of a buffer to STDOUT as either raw or hex byte values. *
+ *                                                                           *
+ * PARAMETERS:                                                               *
+ *   PBYTE pBuf: Pointer to the data being dumped                            *
+ *   ULONG cb  : Number of bytes to dump                                     *
+ *   BOOL  fHex: Output as hex values instead of literal bytes?              *
+ *                                                                           *
+ * RETURNS: N/A                                                              *
+ * ------------------------------------------------------------------------- */
+void DumpBytes( PBYTE pBuf, ULONG cb, BOOL fHex )
+{
+    ULONG i;
+    SHORT sCol = 0;
+
+    for ( i = 0; i < cb; i++ ) {
+        if ( fHex ) {
+            printf("%02X", *(pBuf+i) );
+            sCol += 3;
+            if ( sCol > 75 ) {
+                printf("\n");
+                sCol = 0;
+            } else
+                printf(" ");
+        }
+        else printf("%c", *(pBuf+i) );
+    }
+}
+
+
+/* ------------------------------------------------------------------------- *
+ * PrettyBytes                                                               *
+ *                                                                           *
+ * Dump the contents of a buffer to STDOUT in a nice-looking table with both *
+ * hexadecimal and literal (character) values displayed side-by-side.        *
+ *                                                                           *
+ * PARAMETERS:                                                               *
+ *   PBYTE pBuf: Pointer to the data being dumped                            *
+ *   ULONG cb  : Number of bytes to dump                                     *
+ *                                                                           *
+ * RETURNS: N/A                                                              *
+ * ------------------------------------------------------------------------- */
+void PrettyBytes( PBYTE pBuf, ULONG cb )
+{
+    ULONG i, j, k;
+    USHORT count = 0;
+
+    printf("     +------------------------------------------------+----------------+\n");
+    printf("     |+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F |0123456789ABCDEF|\n");
+    printf("+----+------------------------------------------------+----------------+\n");
+    printf("|0000|");
+    for ( i = 0, j = 0; i < cb; i++ ) {
+        printf("%02X", *(pBuf+i) );
+        count++;
+        if ( count > 15 ) {
+            printf(" |");
+            for ( ; j <= i; j++ ) printf("%c", DISPLAYABLE_CHAR( *(pBuf+j) ));
+            printf("|\n|%04X|", i+1 );
+            count = 0;
+        } else
+            printf(" ");
+    }
+    if ( j < i ) {
+        for ( k = (i%16); k < 16; k++ ) printf("   ");
+        printf("|");
+        for ( ; j <= i; j++ ) printf("%c", DISPLAYABLE_CHAR( *(pBuf+j) ));
+        for ( k = (j%16); k < 16; k++ ) printf(" ");
+        printf("|\n");
+    }
+    printf("+----+------------------------------------------------+----------------+\n");
+    printf("     |+0 +1 +2 +3 +4 +5 +6 +7 +8 +9 +A +B +C +D +E +F |0123456789ABCDEF|\n");
+    printf("     +------------------------------------------------+----------------+\n");
+}
+
+
+/* ------------------------------------------------------------------------- */
+void print_offcell( PSZ pszName, SHORT sValue, BOOL fNL )
+{
+    printf("%-24s = ", pszName);
+    printf( OFFSET_FORMAT(sValue), sValue );
+    if ( fNL )
+        printf(" |\n| ");
+    else
+        printf(" | ");
+}
+
+
+/* ------------------------------------------------------------------------- */
+void ShowDeviceData( PAK_DEV_DIRENTRY pdd, PBYTE pBuf )
+{
+    DESPPD     desPPD = {0};
+    PBYTE      pInfoSeg;
+    PUI_BLOCK  puib;
+    PUIC_BLOCK puicb;
+    ULONG      ulCB,
+               cbDS,
+               cbIS;
+    USHORT     i, j;
+    PSHORT     psRes;
+
+
+    cbDS = sizeof( DESPPD );
+    memcpy( (PBYTE) &desPPD, pBuf, cbDS );
+    pInfoSeg = pBuf + cbDS;
+
+    // Allocate and copy the dynamic data items in DESPPD
+    ulCB = desPPD.stUIList.usBlockListSize;
+    desPPD.stUIList.pBlockList = (PUI_BLOCK) malloc( ulCB );
+    memcpy( desPPD.stUIList.pBlockList, (PUI_BLOCK) pInfoSeg, ulCB );
+    pInfoSeg += ulCB;
+    cbDS += ulCB;
+
+    ulCB = desPPD.stUICList.usNumOfUICs * sizeof( UIC_BLOCK );
+    desPPD.stUICList.puicBlockList = (PUIC_BLOCK) malloc( ulCB );
+    memcpy( desPPD.stUICList.puicBlockList, (PUIC_BLOCK) pInfoSeg, ulCB );
+    pInfoSeg += ulCB;
+    cbDS += ulCB;
+    cbIS = pdd.ulSize - cbDS;
+    desPPD.pPSStringBuff = pInfoSeg;
+
+    // Print header
+    printf("/=============================================================================\\\n");
+    printf("| PRINTER PAK ENTRY                                                           |\n");
+    printf("| %-75s |\n", pdd.szDeviceName );
+    printf("+-----------------------------------------------------------------------------+\n");
+    printf("| %5u bytes total                                                           |\n", pdd.ulSize );
+    printf("|  - %5u bytes in descriptor segment                                        |\n", cbDS );
+    printf("|  - %5u bytes in information segment                                       |\n", cbIS );
+    printf("\\=============================================================================/\n\n");
+
+    printf("\n-------------------------------------------------------------------------------");
+    printf("\n                         DESCRIPTOR SEGMENT (DESPPD)                           ");
+    printf("\n-------------------------------------------------------------------------------\n");
+
+    // Print the structured data from DESPPD
+    // PPD1
+    printf("+-----------------+\n");
+    printf("| desItems (PPD1) |\n");
+    printf("+-----------------+--------------------+--------------------------------------+\n| ");
+    printf("iSizeBuffer              =   %7u | ", desPPD.desItems.iSizeBuffer );
+    print_offcell("ofsExitserver",  desPPD.desItems.ofsExitserver, TRUE );
+    print_offcell("ofsPswrd",       desPPD.desItems.ofsPswrd, FALSE );
+    printf("iScreenAngle             =   %7d |\n| ", desPPD.desItems.iScreenAngle );
+    printf("iPpm                     =   %7d | ", desPPD.desItems.iPpm );
+    printf("usLanguageLevel          =   %7d |\n| ", desPPD.desItems.usLanguageLevel );
+    printf("lFreeVM                  = %9d | ", desPPD.desItems.lFreeVM );
+    print_offcell("ofsTransferNor", desPPD.desItems.ofsTransferNor, TRUE );
+    print_offcell("ofsPrType",      desPPD.desItems.ofsPrType, FALSE );
+    print_offcell("ofsTransferInv", desPPD.desItems.ofsTransferInv, TRUE );
+    print_offcell("ofsPrName",      desPPD.desItems.ofsPrName, FALSE );
+    print_offcell("ofsInitString",  desPPD.desItems.ofsInitString, TRUE );
+    printf("iResDpi                  =   %7d | ", desPPD.desItems.iResDpi );
+    print_offcell("ofsJCLToPS",     desPPD.desItems.ofsJCLToPS, TRUE );
+    printf("ResList.uNumOfRes        =   %7d | ", desPPD.desItems.ResList.uNumOfRes );
+    print_offcell("ofsTermString",  desPPD.desItems.ofsTermString, TRUE );
+    printf("ResList.uResOffset       =   %7d | ", desPPD.desItems.ResList.uResOffset );
+    printf("sDefaultDuplex           =   %7d |\n| ", desPPD.desItems.sDefaultDuplex );
+    printf("ResList.bIsJCLResolution =   %7d | ", desPPD.desItems.ResList.bIsJCLResolution );
+    // Note: the duplex options appear to be unused and will thus be 0 (not -1)
+    printf("ofsDuplexFalse           =   %7d |\n| ", desPPD.desItems.ofsDuplexFalse );
+    printf("lScrFreq                 =   %7d | ", desPPD.desItems.lScrFreq );
+    printf("ofsDuplexNoTumble        =   %7d |\n| ", desPPD.desItems.ofsDuplexNoTumble );
+    printf("fIsColorDevice           =   %7d | ", desPPD.desItems.fIsColorDevice );
+    printf("ofsDuplexTumble          =   %7d |\n| ", desPPD.desItems.ofsDuplexTumble );
+    printf("fIsFileSystem            =   %7d | ", desPPD.desItems.fIsFileSystem );
+    print_offcell("ofsPCFileName",  desPPD.desItems.ofsPCFileName, TRUE );
+    print_offcell("ofsReset",       desPPD.desItems.ofsReset, FALSE );
+#if PSDRIVER == 1
+    printf("fTTSupport               =   %7d |\n", desPPD.desItems.fTTSupport );
+#else
+    printf("                                     |\n");
+#endif
+    printf("+--------------------------------------+--------------------------------------+\n\n");
+
+    // PPD2
+    printf("+----------------+\n");
+    printf("| desPage (PPD2) |\n");
+    printf("+----------------+---------------------+--------------------------------------+\n| ");
+#if PSDRIVER > 2
+    printf("                                     | ");
+#else
+    print_offcell("ofsDfpgsz",       desPPD.desPage.ofsDfpgsz, FALSE );
+#endif
+    printf("iImgpgpairs              =   %7d |\n| ", desPPD.desPage.iImgpgpairs );
+    printf("fIsVariablePaper         =   %7d | ", desPPD.desPage.fIsVariablePaper );
+    print_offcell("ofsImgblPgsz",    desPPD.desPage.ofsImgblPgsz, TRUE );
+#if PSDRIVER > 2
+    printf("                                     | ");
+#else
+    print_offcell("ofsDefimagearea", desPPD.desPage.ofsDefimagearea, FALSE );
+#endif
+    print_offcell("ofsCustomPageSize", desPPD.desPage.ofsCustomPageSize, TRUE );
+#if PSDRIVER > 2
+    printf("                                     | ");
+#else
+    print_offcell("ofsDefpaperdim",  desPPD.desPage.ofsDefpaperdim, FALSE );
+#endif
+    printf("iCustomPageSizeMinWidth  =   %7d |\n| ", desPPD.desPage.iCustomPageSizeMinWidth );
+#if PSDRIVER > 2
+    printf("                                     | ");
+#else
+    printf("iCmpgpairs               =   %7d | ", desPPD.desPage.iCmpgpairs );
+#endif
+    printf("iCustomPageSizeMaxWidth  =   %7d |\n| ", desPPD.desPage.iCustomPageSizeMaxWidth );
+#if PSDRIVER > 2
+    printf("                                     | ");
+#else
+    print_offcell("ofsLspgCmnds",    desPPD.desPage.ofsLspgCmnds, FALSE );
+#endif
+    printf("iCustomPageSizeMinHeight =   %7d |\n| ", desPPD.desPage.iCustomPageSizeMinHeight );
+    printf("iDmpgpairs               =   %7d | ", desPPD.desPage.iDmpgpairs );
+    printf("iCustomPageSizeMaxHeight =   %7d |\n| ", desPPD.desPage.iCustomPageSizeMaxHeight );
+    print_offcell("ofsDimxyPgsz",    desPPD.desPage.ofsDimxyPgsz, FALSE );
+#if PSDRIVER > 2
+    printf("sReserved1               =   %7d |\n| ", desPPD.desPage.sReserved1 );
+    printf("                                     | ");
+    printf("sReserved2               =   %7d |\n", desPPD.desPage.sReserved2 );
+#else
+    printf("                                     |\n");
+#endif
+    printf("+--------------------------------------+--------------------------------------+\n\n");
+
+    // PPD3
+    printf("+-------------------+\n");
+    printf("| desInpbins (PPD3) |\n");
+    printf("+-------------------+------------------+--------------------------------------+\n| ");
+    printf("iManualfeed              =   %7d | ", desPPD.desInpbins.iManualfeed );
+    printf("iInpbinpairs             =   %7d |\n| ", desPPD.desInpbins.iInpbinpairs );
+    print_offcell("ofsManualtrue",   desPPD.desInpbins.ofsManualtrue, FALSE );
+    print_offcell("ofsCmInpbins",    desPPD.desInpbins.ofsCmInpbins, TRUE );
+    print_offcell("ofsManualfalse",  desPPD.desInpbins.ofsManualfalse, FALSE );
+    printf("iNumOfPageSizes          =   %7d |\n| ", desPPD.desInpbins.iNumOfPageSizes );
+    print_offcell("ofsDefinputslot", desPPD.desInpbins.ofsDefinputslot, FALSE );
+    print_offcell("ofsPageSizes",    desPPD.desInpbins.ofsPageSizes, FALSE );
+    printf("\n+--------------------------------------+--------------------------------------+\n\n");
+
+    // PPD4
+    printf("+-------------------+\n");
+    printf("| desOutbins (PPD4) |\n");
+    printf("+-------------------+------------------+--------------------------------------+\n| ");
+    printf("fIsDefoutorder           =   %7d | ", desPPD.desOutbins.fIsDefoutorder );
+    print_offcell("ofsDefoutputbin", desPPD.desOutbins.ofsDefoutputbin, TRUE );
+    print_offcell("ofsOrdernormal",  desPPD.desOutbins.ofsOrdernormal, FALSE );
+    printf("iOutbinpairs             =   %7d |\n| ", desPPD.desOutbins.iOutbinpairs );
+    print_offcell("ofsOrderreverse", desPPD.desOutbins.ofsOrderreverse, FALSE );
+    print_offcell("ofsCmOutbins",    desPPD.desOutbins.ofsCmOutbins, FALSE );
+    printf("\n+--------------------------------------+--------------------------------------+\n\n");
+
+    // PPD5
+    printf("+-----------------+\n");
+    printf("| desFonts (PPD5) |\n");
+    printf("+-----------------+--------------------+\n| ");
+    print_offcell("ofsDeffont", desPPD.desFonts.ofsDeffont, TRUE );
+    printf("iFonts                   =   %7d |\n| ", desPPD.desFonts.iFonts );
+    print_offcell("ofsFontnames", desPPD.desFonts.ofsFontnames, FALSE );
+    printf("\n+--------------------------------------+\n\n");
+
+    // PPD6
+    printf("+-----------------+\n");
+    printf("| desForms (PPD6) |\n");
+    printf("+-----------------+--------------------+\n| ");
+    printf("usFormCount              =   %7d |\n| ", desPPD.desForms.usFormCount );
+    print_offcell("ofsFormTable", desPPD.desForms.ofsFormTable, TRUE );
+    print_offcell("ofsFormIndex", desPPD.desForms.ofsFormIndex, FALSE );
+    printf("\n+--------------------------------------+\n\n");
+
+    // UI_LIST
+    printf("+--------------------+\n");
+    printf("| stUIList (UI_LIST) |\n");
+    printf("+--------------------+--------------------------------------------------------+\n");
+    printf("| usNumOfBlocks       =   %7d                                             |\n", desPPD.stUIList.usNumOfBlocks );
+    printf("| usBlockListSize     =   %7d                                             |\n", desPPD.stUIList.usBlockListSize );
+    puib = desPPD.stUIList.pBlockList;
+    for ( i = 0; puib && desPPD.stUIList.usBlockListSize && i < desPPD.stUIList.usNumOfBlocks; i++ ) {
+        printf("+-----------------------------------------------------------------------------+\n");
+        printf("| pBlockList[ %2d ]:                                                           |\n", i );
+//                OFFSET_TO_PSZ(puib->ofsUITransString, pInfoSeg) );
+//                OFFSET_TO_PSZ(puib->ofsUIName, pInfoSeg) );
+        printf("|    ofsUIName        = ");
+        printf( OFFSET_FORMAT((SHORT)(puib->ofsUIName)), puib->ofsUIName );
+        printf("                                             |\n");
+        printf("|    ofsUITransString = ");
+        printf( OFFSET_FORMAT((SHORT)(puib->ofsUITransString)), puib->ofsUITransString );
+        printf("                                             |\n");
+        printf("|    usOrderDep       =   %7d                                             |\n", puib->usOrderDep );
+        printf("|    usDisplayOrder   =   %7d                                             |\n", puib->usDisplayOrder );
+        printf("|    usUILocation     =   %7d                                             |\n", puib->usUILocation );
+        printf("|    usSelectType     =   %7d                                             |\n", puib->usSelectType );
+        printf("|    ucGroupType      =   %7d                                             |\n", puib->ucGroupType );
+        printf("|    ucPanelID        =   %7d                                             |\n", puib->ucPanelID    );
+        printf("|    usDefaultEntry   =   %7d                                             |\n", puib->usDefaultEntry );
+        printf("|    usNumOfEntries   =   %7d                                             |\n", puib->usNumOfEntries );
+        printf("|    uiEntry[]................................................................|\n");
+        for ( j = 0; j < puib->usNumOfEntries; j++ ) {
+            printf("|    : %2d:  ofsOption = %#6x   ofsTransString = %#6x   ofsValue = %#6x :|\n",
+                    j, puib->uiEntry[j].ofsOption, puib->uiEntry[j].ofsTransString, puib->uiEntry[j].ofsValue );
+            // OFFSET_TO_PSZ(puib->uiEntry[j].ofsOption, pInfoSeg) );
+            // OFFSET_TO_PSZ(puib->uiEntry[j].ofsTransString, pInfoSeg) );
+        }
+        printf("|    .........................................................................|\n");
+        INCREMENT_BLOCK_PTR( puib );
+    }
+    printf("+-----------------------------------------------------------------------------+\n\n");
+
+    // UIC_LIST
+    printf("+----------------------+\n");
+    printf("| stUICList (UIC_LIST) |\n");
+    printf("+----------------------+------------------------------------------------------+\n");
+    printf("| usNumOfUICs             =   %7d                                         |\n", desPPD.stUICList.usNumOfUICs );
+    puicb = desPPD.stUICList.puicBlockList;
+    for ( i = 0; puicb && i < desPPD.stUICList.usNumOfUICs; i++ ) {
+        printf("+-----------------------------------------------------------------------------+\n");
+        printf("| puicBlockList[ %2d ]:                                                        |\n", i );
+        printf("|    uicEntry1.ofsUIBlock =   %7d                                         |\n", puicb->uicEntry1.ofsUIBlock );
+        printf("|    uicEntry1.bOption    =%#10x                                         |\n", puicb->uicEntry1.bOption );
+        printf("|    uicEntry2.ofsUIBlock =   %7d                                         |\n", puicb->uicEntry2.ofsUIBlock );
+        printf("|    uicEntry2.bOption    =%#10x                                         |\n", puicb->uicEntry2.bOption );
+        puicb++;
+    }
+    printf("+-----------------------------------------------------------------------------+\n\n");
+
+    printf("\n-------------------------------------------------------------------------------");
+    printf("\n                            INFORMATION SEGMENT                                ");
+    printf("\n-------------------------------------------------------------------------------\n");
+    PrettyBytes( pInfoSeg, cbIS );
+    printf("\n");
+
+    free( desPPD.stUIList.pBlockList );
+    free( desPPD.stUICList.puicBlockList );
+}
+
+
+/* ------------------------------------------------------------------------- *
+ * OffsetToCommand                                                           *
+ *                                                                           *
+ * Given an offset into the data buffer, convert the compressed command      *
+ * string at that address into a normal, readable string.  Any newline chars *
+ * will be stripped out in order to improve readability.  The string will be *
+ * enclosed in quotes.                                                       *
+ *                                                                           *
+ * PARAMETERS:                                                               *
+ *   SHORT sOff: Offset into the data buffer pIn                             *
+ *   PBYTE pIn : Pointer to the input data buffer                            *
+ *   PBYTE pOut: Pointer to a buffer into which the output string will be    *
+ *               written (the buffer is assumed to be large enough)          *
+ *                                                                           *
+ * RETURNS: PSZ                                                              *
+ *   Modified string (same as pOut)                                          *
+ * ------------------------------------------------------------------------- */
+PSZ OffsetToCommand( SHORT sOff, PBYTE pIn, PBYTE pOut )
+{
+    PSZ    pszTmp;
+    USHORT usRC;
+
+    if ( !pOut )
+        return ( pOut );
+
+    if ( !pIn || sOff < 1 )
+        strcpy( pOut, "(none)");
+    else {
+        usRC = DecompressString( OFFSET_TO_PSZ( sOff, pIn ), pOut );
+        if ( usRC ) {
+            pszTmp = (PSZ) calloc( usRC + 3, sizeof( char ));
+            if ( pszTmp ) {
+                USHORT i, j;
+
+                sprintf( pszTmp, "\"%s\"", (PSZ) pOut );
+                usRC = strlen( pszTmp );
+                for ( i = 0, j = 0; i < usRC; i++ ) {
+                    if ( pszTmp[ i ] != '\r' && pszTmp[ i ] != '\n')
+                        pOut[ j++ ] = pszTmp[ i ];
+                }
+                pOut[ j ] = 0;
+                free( pszTmp );
+            }
+        }
+        else if ( *((PSZ) pIn + sOff ))
+            strcpy( pOut, (PSZ) pIn + sOff );
+        else
+            strcpy( pOut, "(none)");
+    }
+    return ( pOut );
+}
+
+
+/* ------------------------------------------------------------------------- *
+ * OffsetToProperCommand                                                     *
+ *                                                                           *
+ * Given an offset into the data buffer, convert the compressed command      *
+ * string at that address into a normal, readable string.  Any non-ASCII     *
+ * characters will be replaced with hex strings.  The string is not quoted.  *
+ * Basically, this function is used for the *JCL command strings, which may  *
+ * contain odd byte values which won't be handled normally.  It also doesn't *
+ * check that the offset is > 0, because for the first three JCL commands,   *
+ * the correct offset could well BE 0 (as they appear, if they exist at all, *
+ * right at the start of the data segment).                                  *
+ *                                                                           *
+ * PARAMETERS:                                                               *
+ *   SHORT sOff: Offset into the data buffer pIn                             *
+ *   PBYTE pIn : Pointer to the input data buffer                            *
+ *   PBYTE pOut: Pointer to a buffer into which the output string will be    *
+ *               written (the buffer is assumed to be large enough)          *
+ *                                                                           *
+ * RETURNS: PSZ                                                              *
+ *   Modified string (same as pOut)                                          *
+ * ------------------------------------------------------------------------- */
+PSZ OffsetToProperCommand( SHORT sOff, PBYTE pIn, PBYTE pOut )
+{
+    PSZ    pszTmp;
+    USHORT usRC;
+
+    if ( !pIn || !pOut || sOff < 0 )
+        strcpy( pOut, "");
+    else {
+        usRC = DecompressString( (PSZ) pIn+sOff, pOut );
+        if ( usRC ) {
+            pszTmp = (PSZ) calloc( 4 * usRC + 1, sizeof( char ));
+            if ( pszTmp ) {
+                USHORT i, j;
+
+                strcpy( pszTmp, (PSZ) pOut );
+                usRC = strlen( pszTmp );
+                for ( i = 0, j = 0; i < usRC; i++ ) {
+                    if ( pszTmp[ i ] < 32 || pszTmp[ i ] > 127 ) {
+                        sprintf( (PSZ) pOut+j, "<%02X>", pszTmp[ i ] );
+                        j+= 4;
+                    }
+                    else pOut[ j++ ] = pszTmp[ i ];
+                }
+                pOut[ j ] = 0;
+                free( pszTmp );
+            }
+        }
+        else if ( *((PSZ) pIn + sOff ))
+            strcpy( pOut, (PSZ) pIn + sOff );
+        else
+            strcpy( pOut, "");
+    }
+    return ( pOut );
+}
+
+
+/* ------------------------------------------------------------------------- */
+void ShowReadableData( PAK_DEV_DIRENTRY pdd, PBYTE pBuf )
+{
+    DESPPD     desPPD = {0};
+    PBYTE      pInfoSeg,
+               pScratch;
+    PUI_BLOCK  puib;
+    PUIC_BLOCK puicb;
+    ULONG      ulCB;
+    USHORT     i, j;
+    PSHORT     psVal;
+    PLONG      plVal;
+    SHORT      sIdx, sPDX, sPDY;
+    PSZ        psz;
+
+
+    ulCB = sizeof( DESPPD );
+    memcpy( (PBYTE) &desPPD, pBuf, ulCB );
+    pInfoSeg = pBuf + ulCB;
+
+    // Allocate and copy the dynamic data items in DESPPD
+    ulCB = desPPD.stUIList.usBlockListSize;
+    desPPD.stUIList.pBlockList = (PUI_BLOCK) malloc( ulCB );
+    memcpy( desPPD.stUIList.pBlockList, (PUI_BLOCK) pInfoSeg, ulCB );
+    pInfoSeg += ulCB;
+
+    ulCB = desPPD.stUICList.usNumOfUICs * sizeof( UIC_BLOCK );
+    desPPD.stUICList.puicBlockList = (PUIC_BLOCK) malloc( ulCB );
+    memcpy( desPPD.stUICList.puicBlockList, (PUIC_BLOCK) pInfoSeg, ulCB );
+    pInfoSeg += ulCB;
+    desPPD.pPSStringBuff = pInfoSeg;
+
+    // Create a scratch buffer for decompressing strings
+    pScratch = (PBYTE) calloc( desPPD.desItems.iSizeBuffer, 1 );
+    if ( !pScratch ) {
+        printf("Failed to allocate memory (%u bytes) for working buffer.\n", desPPD.desItems.iSizeBuffer );
+        return;
+    }
+
+    // Print header
+    printf("==============================================================================\n");
+    printf("PRINTER PAK ENTRY  -  \"%s\"\n", pdd.szDeviceName );
+    printf("==============================================================================\n");
+
+    printf("\nBasic Data\n----------\n");
+    printf("Language level:                      %d\n", desPPD.desItems.usLanguageLevel );
+    printf("Password:                            %s\n", OFFSET_TO_PSZ( desPPD.desItems.ofsPswrd, pInfoSeg ));
+    printf("PPM:                                 %d\n", desPPD.desItems.iPpm );
+    printf("FreeVM:                              %d\n", desPPD.desItems.lFreeVM );
+    // AFAIK desPPD.desItems.ofsPrType is not used, but show it anyway
+    printf("Printer type:                        %s\n", OFFSET_TO_PSZ( desPPD.desItems.ofsPrType, pInfoSeg ));
+    printf("Printer name:                        %s\n", (PSZ)( pInfoSeg + desPPD.desItems.ofsPrName ));
+    printf("ColorDevice:                         %d\n", desPPD.desItems.fIsColorDevice );
+    printf("FileSystem:                          %d\n", desPPD.desItems.fIsFileSystem );
+    printf("PC Filename:                         %s\n", (desPPD.desItems.ofsPCFileName >= 0) ?
+                                                        (PSZ)( pInfoSeg + desPPD.desItems.ofsPCFileName ) :
+                                                        "(none)");
+    printf("Default DPI:                         %d\n", desPPD.desItems.iResDpi );
+#if PSDRIVER == 1
+    printf("TrueType font support:               %d\n", desPPD.desItems.fTTSupport );
+#endif
+
+    // I don't think the following are actually used; the available resolutions
+    // are apparently defined only as UIOption items.
+    if ( desPPD.desItems.ResList.uNumOfRes ) {
+        if ( desPPD.desItems.ResList.bIsJCLResolution )
+            printf("Defined JCL resolutions (%d)\n", desPPD.desItems.ResList.uNumOfRes );
+        else
+            printf("Defined resolutions (%d)\n", desPPD.desItems.ResList.uNumOfRes );
+        if ( desPPD.desItems.ResList.uResOffset > 0 ) {
+            psVal = (PSHORT)((PBYTE)(pInfoSeg + desPPD.desItems.ResList.uResOffset));
+            for ( i = 0; i < desPPD.desItems.ResList.uNumOfRes; i++ ) {
+                printf(" - %d\n", *psVal );
+                psVal++;
+            }
+        }
+    }
+
+    printf("ScreenAngle:                         %d\n", desPPD.desItems.iScreenAngle );
+    printf("ScreenFreq:                          %d\n", desPPD.desItems.lScrFreq );
+    printf("Reset command:                       %s\n", OFFSET_TO_PSZ( desPPD.desItems.ofsReset, pInfoSeg ));
+    printf("ExitServer command:                  %s\n", OffsetToCommand( desPPD.desItems.ofsExitserver, pInfoSeg, pScratch ));
+    printf("Transfer Normalized command:         %s\n", OffsetToCommand( desPPD.desItems.ofsTransferNor, pInfoSeg, pScratch ));
+    printf("Transfer Normalized.Inverse command: %s\n", OffsetToCommand( desPPD.desItems.ofsTransferInv, pInfoSeg, pScratch ));
+    psz = OffsetToProperCommand( desPPD.desItems.ofsInitString, pInfoSeg, pScratch );
+    printf("JCLBegin/InitPostScriptMode command: %s\n", strlen(psz)? psz: "(none)");
+    psz = OffsetToProperCommand( desPPD.desItems.ofsJCLToPS, pInfoSeg, pScratch );
+    printf("JCLToPSInterpreter command:          %s\n", strlen(psz)? psz: "(none)");
+    psz = OffsetToProperCommand( desPPD.desItems.ofsTermString, pInfoSeg, pScratch );
+    printf("JCLEnd/TermPostScriptMode command:   %s\n", strlen(psz)? psz: "(none)");
+
+    printf("\nPage Properties\n---------------\n");
+    // Several of these appear to be deprecated in favour of UI items and are
+    // unused:
+    //   desPage.iCmpgpairs
+    //   desPage.ofsLspgCmnds
+    //   printf("Default page size:                   %s\n", OFFSET_TO_PSZ( desPPD.desPage.ofsDfpgsz, pInfoSeg ));
+    //   printf("Default imageable area:              %s\n", OFFSET_TO_PSZ( desPPD.desPage.ofsDefimagearea, pInfoSeg ));
+    //   printf("Default paper dimensions:            %s\n", OFFSET_TO_PSZ( desPPD.desPage.ofsDefpaperdim, pInfoSeg ));
+    printf("Variable paper:                      %d\n", desPPD.desPage.fIsVariablePaper );
+    printf("Paper dimension pairs:               %d\n", desPPD.desPage.iDmpgpairs );
+    psVal = (PSHORT)( pInfoSeg + desPPD.desPage.ofsDimxyPgsz );
+    for ( i = 0; i < desPPD.desPage.iDmpgpairs; i++ ) {
+        sIdx = (SHORT) *psVal;
+        psVal++;
+        sPDX = (SHORT) *psVal;
+        psVal++;
+        sPDY = (SHORT) *psVal;
+        psVal++;
+        printf("  %2d - %4d %4d\n", sIdx, sPDX, sPDY );
+    }
+    printf("Imageable coordinate pairs: %d\n", desPPD.desPage.iImgpgpairs );
+    psVal = (PSHORT)( pInfoSeg + desPPD.desPage.ofsImgblPgsz );
+    for ( i = 0; i < desPPD.desPage.iImgpgpairs; i++ ) {
+        sIdx = (SHORT) *psVal;
+        psVal++;
+        sPDX = (SHORT) *psVal;
+        psVal++;
+        sPDY = (SHORT) *psVal;
+        psVal++;
+        printf("  %2d - %4d %4d ", sIdx, sPDX, sPDY );
+        sPDX = (SHORT) *psVal;
+        psVal++;
+        sPDY = (SHORT) *psVal;
+        psVal++;
+        psz = (PSZ) psVal;
+        printf("%4d %4d  (%s)\n", sPDX, sPDY, psz );
+        psVal = (PSHORT) ((PSZ)( psz + strlen( psz ) + 1 ));
+    }
+    printf("Custom Page Size command:            %s\n", OffsetToCommand( desPPD.desPage.ofsCustomPageSize, pInfoSeg, pScratch ));
+    printf("Custom Page min width:               %d\n", desPPD.desPage.iCustomPageSizeMinWidth );
+    printf("Custom Page max width:               %d\n", desPPD.desPage.iCustomPageSizeMaxWidth );
+    printf("Custom Page min height:              %d\n", desPPD.desPage.iCustomPageSizeMinHeight );
+    printf("Custom Page max height:              %d\n", desPPD.desPage.iCustomPageSizeMaxHeight );
+
+    printf("\nInput Trays\n-----------\n");
+    // None of these items actually seem to be used or set anywhere; they
+    // are presumably deprecated, as input slots are defined as UI items
+    // (under desPPD.stUIList) in practice.
+    printf("Manual Feed:                         %d\n", desPPD.desInpbins.iManualfeed );
+    printf("Manual Feed set command:             %s\n", OffsetToCommand( desPPD.desInpbins.ofsManualtrue, pInfoSeg, pScratch ));
+    printf("Manual Feed unset disable:           %s\n", OffsetToCommand( desPPD.desInpbins.ofsManualfalse, pInfoSeg, pScratch ));
+    printf("Default input tray:                  %s\n", OFFSET_TO_PSZ( desPPD.desInpbins.ofsDefinputslot, pInfoSeg ));
+    printf("Input tray pairs:                    %d\n", desPPD.desInpbins.iInpbinpairs );
+    printf("Input tray paper sizes:              %d\n", desPPD.desInpbins.iNumOfPageSizes );
+    // No need to even try to handle desPPD.desInpbins.ofsCmInpbins or
+    // desPPD.desInpbins.ofsPageSizes -- they are deprecated and no longer used
+
+    printf("\nOutput Trays\n------------\n");
+    printf("Default output order:                %s\n", ( desPPD.desOutbins.fIsDefoutorder? "Reverse": "Normal" ));
+    printf("Normal Output command:               %s\n", OffsetToCommand( desPPD.desOutbins.ofsOrdernormal, pInfoSeg, pScratch ));
+    printf("Reverse Output command:              %s\n", OffsetToCommand( desPPD.desOutbins.ofsOrderreverse, pInfoSeg, pScratch ));
+    printf("Default output tray:                 %s\n", OFFSET_TO_PSZ( desPPD.desOutbins.ofsDefoutputbin, pInfoSeg )); // not used?
+    printf("Output tray pairs:                   %d\n", desPPD.desOutbins.iOutbinpairs );
+    // desPPD.desOutbins.ofsCmOutbins is not used or set anywhere, so ignore it
+
+    printf("\nFonts\n-----\n");
+    printf("Default font:                        %s\n", OFFSET_TO_PSZ( desPPD.desFonts.ofsDeffont, pInfoSeg ));
+    printf("Supported hardware fonts:            %d\n", desPPD.desFonts.iFonts );
+    psz = OFFSET_TO_PSZ( desPPD.desFonts.ofsFontnames, pInfoSeg );
+    for ( i = 0; (i < desPPD.desFonts.iFonts) && *psz; i++ ) {
+        printf("  - %s\n", psz );
+        psz += strlen( psz ) + 1;
+    }
+
+    printf("\nForms\n-----\n");
+    // Not entirely sure these are used at all either
+    printf("Number of forms:                     %d\n", desPPD.desForms.usFormCount );
+    if ( desPPD.desForms.usFormCount ) {
+        plVal = (PLONG)(pInfoSeg + desPPD.desForms.ofsFormIndex);
+        for ( i = 0; (i < desPPD.desForms.usFormCount) && *psz; i++ ) {
+            printf("  - %s\n", OffsetToCommand( (SHORT) *plVal, pInfoSeg, pScratch ));
+            plVal++;
+        }
+    }
+
+    printf("\n\nUser Interface Items\n--------------------\n");
+    printf("Total size of UI list:               %d\n", desPPD.stUIList.usBlockListSize );
+    printf("Number of UI items:                  %d\n", desPPD.stUIList.usNumOfBlocks );
+    puib = desPPD.stUIList.pBlockList;
+    for ( i = 0; puib && desPPD.stUIList.usBlockListSize && i < desPPD.stUIList.usNumOfBlocks; i++ ) {
+        printf("\n* \"%s\"  (%d)\n", OFFSET_TO_PSZ( puib->ofsUIName, pInfoSeg ), i );
+        printf("   Translation string:               \"%s\"\n", OFFSET_TO_PSZ( puib->ofsUITransString, pInfoSeg ));
+        printf("   Order index value:                %d\n", puib->usOrderDep );
+        printf("   Display order:                    %d\n", puib->usDisplayOrder );
+        printf("   Location:                         ");
+        switch( puib->usUILocation ) {
+            case UI_ORDER_ANYSETUP   : printf("Any\n");        break;
+            case UI_ORDER_JCLSETUP   : printf("JCL\n");        break;
+            case UI_ORDER_PAGESETUP  : printf("Page\n");       break;
+            case UI_ORDER_DOCSETUP   : printf("Document\n");   break;
+            case UI_ORDER_PROLOGSETUP: printf("Prolog\n");     break;
+            case UI_ORDER_EXITSERVER : printf("ExitServer\n"); break;
+            default                  : printf("Unknown\n");    break;
+        }
+        printf("   UI selection type:                ");
+        switch( puib->usSelectType ) {
+            case UI_SELECT_BOOLEAN : printf("Boolean\n");  break;
+            case UI_SELECT_PICKMANY: printf("PickMany\n"); break;
+            case UI_SELECT_PICKONE : printf("PickOne\n");  break;
+            default                : printf("Unknown\n");  break;
+        }
+        printf("   Scope:                            %s\n",
+                ( puib->ucGroupType == UIGT_INSTALLABLEOPTION ) ? "Printer property": "Job property");
+        printf("   Panel ID:                         ");
+        switch ( puib->ucPanelID ) {
+            case UIP_OS2_FEATURE   : printf("IBM\n");  break;
+            case UIP_OEM_FEATURE   : printf("OEM\n");  break;
+            case UIP_PREDEF_FEATURE: printf("Predefined\n");  break;
+            default                : printf("Unknown\n");  break;
+        }
+        printf("   Default value:                    %d\n", puib->usDefaultEntry );
+        printf("   Number of values:                 %d\n", puib->usNumOfEntries );
+        if ( puib->usNumOfEntries ) {
+            for ( j = 0; j < puib->usNumOfEntries; j++ ) {
+                printf("   - Name:                           \"%s\"  (%d)\n", OFFSET_TO_PSZ( puib->uiEntry[j].ofsOption, pInfoSeg ), j );
+                printf("     Translation:                    \"%s\"\n", OFFSET_TO_PSZ( puib->uiEntry[j].ofsTransString, pInfoSeg ));
+                printf("     Value:                          %s\n", OffsetToCommand( puib->uiEntry[j].ofsValue, pInfoSeg, pScratch ));
+            }
+        }
+        INCREMENT_BLOCK_PTR( puib );
+    }
+
+    printf("\n\nUser Interface Constraints\n--------------------------\n");
+    printf("Number of mutually exlusive item sets: %d\n", desPPD.stUICList.usNumOfUICs );
+    puicb = desPPD.stUICList.puicBlockList;
+    for ( i = 0; puicb && i < desPPD.stUICList.usNumOfUICs; i++ ) {
+
+        /*
+        ** Despite the name, the "ofsUIBlock" values are not pointer offsets;
+        ** rather, they are the index of the corresponding UI_LIST item in
+        ** "stUIList.pBlockList".  "bOption" is a bitmap flagging the affected
+        ** values (that is, items in the item's uiEntry[] array).  e.g.
+        **      ofsUIBlock = 2
+        **      bOption    = 13  (binary 1101)
+        ** indicates the 1st, 3rd, and 4th values of the third UI item.
+        */
+        puib = desPPD.stUIList.pBlockList;
+        for ( j = 0; j < puicb->uicEntry1.ofsUIBlock; j++ )
+            INCREMENT_BLOCK_PTR( puib );
+        printf(" - (%s", OFFSET_TO_PSZ( puib->ofsUIName, pInfoSeg ));
+        if ( puicb->uicEntry1.bOption ) {
+            printf(" ==");
+            for ( j = 0; j < 32 && j < puib->usNumOfEntries; j++ ) {
+                if (( puicb->uicEntry1.bOption >> j ) & 1 )
+                    printf(" %s", OFFSET_TO_PSZ( puib->uiEntry[j].ofsOption, pInfoSeg ));
+            }
+        }
+        printf(") with ");
+
+        puib = desPPD.stUIList.pBlockList;
+        for ( j = 0; j < puicb->uicEntry2.ofsUIBlock; j++ )
+            INCREMENT_BLOCK_PTR( puib );
+        printf("(%s", OFFSET_TO_PSZ( puib->ofsUIName, pInfoSeg ));
+        if ( puicb->uicEntry2.bOption ) {
+            printf(" ==");
+            for ( j = 0; j < 32 && j < puib->usNumOfEntries; j++ ) {
+                if (( puicb->uicEntry2.bOption >> j ) & 1 )
+                    printf(" %s", OFFSET_TO_PSZ( puib->uiEntry[j].ofsOption, pInfoSeg ));
+            }
+        }
+        printf(")\n");
+
+        puicb++;
+    }
+
+    free( desPPD.stUIList.pBlockList );
+    free( desPPD.stUICList.puicBlockList );
+    free( pScratch );
+}
+
+
+/* ------------------------------------------------------------------------- *
+ * PrintToPPD                                                                *
+ *                                                                           *
+ * Print a parameter/string value pair, formatted for PPD output.            *
+ *                                                                           *
+ * PARAMETERS:                                                               *
+ *   PSZ pszName   : Name of the parameter as it will appear in the PPD      *
+ *                   (must start with * and include a trailing colon)        *
+ *   SHORT usOffset: Offset of the string value within the buffer            *
+ *   PBYTE pBuf    : Data buffer from the PAK file                           *
+ *   PSZ pszDefault: Default value in case there is no value defined in the  *
+ *                   buffer; specify NULL to omit the parameter entirely in  *
+ *                   such a case                                             *
+ *                                                                           *
+ * RETURNS: N/A                                                              *
+ * ------------------------------------------------------------------------- */
+void PrintToPPD( PSZ pszName, SHORT usOffset, PBYTE pBuf, PSZ pszDefault )
+{
+    if ( usOffset < 1 ) {
+        if ( pszDefault ) printf("%-23s \"%s\"\n", pszName, pszDefault );
+    }
+    else
+        printf("%-23s \"%s\"\n", pszName, OFFSET_TO_PSZ( usOffset, pBuf ));
+
+    return;
+}
+
+
+/* ------------------------------------------------------------------------- */
+void GeneratePPD( PBYTE pBuf )
+{
+    DESPPD     desPPD = {0};        // structure of main descriptor segment
+    PBYTE      pInfoSeg,            // pointer to free-form information segment
+               pScratch;            // work buffer, mostly for decompressing commands
+    PUI_BLOCK  puib,                // pointer to a UI block
+               puiPaper;            // pointer to the PageSize UI block
+    PUIC_BLOCK puicb;               // pointer to a UI constraints block
+    ULONG      ulCB;
+    USHORT     usRC,
+               i, j, k;
+    PSHORT     psVal;
+    PLONG      plVal;
+    SHORT      sIdx,                // form index cross-reference
+               sX1, sY1, sX2, sY2;  // area coordinates
+    PSZ        psz,                 // general-purpose string pointer
+               pszName,             // current UI item or form name
+               pszXlate,            // current UI item or form translation name
+               pszDefault,          // current UI item default
+               pszDefPage;          // name of default PageSize
+
+
+    // Copy the buffer contents into our data structure
+    ulCB = sizeof( DESPPD );
+    memcpy( (PBYTE) &desPPD, pBuf, ulCB );
+    pInfoSeg = pBuf + ulCB;
+
+    // Allocate and copy the dynamic data items in DESPPD
+    ulCB = desPPD.stUIList.usBlockListSize;
+    desPPD.stUIList.pBlockList = (PUI_BLOCK) malloc( ulCB );
+    memcpy( desPPD.stUIList.pBlockList, (PUI_BLOCK) pInfoSeg, ulCB );
+    pInfoSeg += ulCB;
+
+    ulCB = desPPD.stUICList.usNumOfUICs * sizeof( UIC_BLOCK );
+    desPPD.stUICList.puicBlockList = (PUIC_BLOCK) malloc( ulCB );
+    memcpy( desPPD.stUICList.puicBlockList, (PUIC_BLOCK) pInfoSeg, ulCB );
+    pInfoSeg += ulCB;
+    desPPD.pPSStringBuff = pInfoSeg;
+
+    // Create a scratch buffer for decompressing strings
+    pScratch = (PBYTE) calloc( desPPD.desItems.iSizeBuffer, 1 );
+
+    //
+    // Required headers
+    //
+    printf("*PPD-Adobe:             \"4.3\"\n");
+    printf("*FormatVersion:         \"4.3\"\n");
+    printf("*FileVersion:           \"1.0\"\n");
+    printf("*LanguageVersion:       English\n");
+    printf("*LanguageEncoding:      OS2-850\n");
+    printf("*Manufacturer:          \"Autogenerated by pakfile utility\"\n");
+
+    //
+    // Identification & version parameters
+    //
+    printf("*Product:               \"(%s)\"\n", (PSZ)( pInfoSeg + desPPD.desItems.ofsPrName ));
+    printf("*ModelName:             \"%s\"\n",   (PSZ)( pInfoSeg + desPPD.desItems.ofsPrName ));
+    printf("*ShortNickName:         \"%s\"\n",   (PSZ)( pInfoSeg + desPPD.desItems.ofsPrName ));
+    printf("*NickName:              \"%s\"\n",   (PSZ)( pInfoSeg + desPPD.desItems.ofsPrName ));
+    printf("*PCFileName:            \"%s\"\n", (desPPD.desItems.ofsPCFileName >= 0) ?
+                                               (PSZ)( pInfoSeg + desPPD.desItems.ofsPCFileName ) :
+                                               "PRINTER.PPD");
+    printf("*PSVersion:             \"(%d) 001\"\n", ((desPPD.desItems.usLanguageLevel < 2) ? 0 :
+                                                      (desPPD.desItems.usLanguageLevel * 1000)) + 10 );
+    printf("*Languagelevel:         \"%d\"\n", desPPD.desItems.usLanguageLevel );
+
+    //
+    // Basic capabilities
+    //
+    printf("*ColorDevice:           %s\n", (desPPD.desItems.fIsColorDevice == 1) ? "True": "False");
+    printf("*FileSystem:            %s\n", (desPPD.desItems.fIsFileSystem == 1)  ? "True": "False");
+#if PSDRIVER == 1
+    if ( desPPD.desItems.fTTSupport == 1 )
+        printf("*TTRasterizer:          Type42\n");
+#endif
+    if ( desPPD.desItems.iPpm > 0 )
+        printf("*Throughput:            \"%d\"\n", desPPD.desItems.iPpm );
+    if ( desPPD.desItems.lFreeVM > 0 )
+        printf("*FreeVM:                \"%d\"\n", desPPD.desItems.lFreeVM );
+
+    PrintToPPD("*Password:", desPPD.desItems.ofsPswrd, pInfoSeg, NULL );
+    if (( desPPD.desItems.ofsReset > 0 ) &&
+        ( DecompressString( OFFSET_TO_PSZ( desPPD.desItems.ofsReset, pInfoSeg ), pScratch ) > 0 ))
+    {
+        printf("*Reset:                 \"%s\"\n", pScratch );
+    }
+    if (( desPPD.desItems.ofsExitserver > 0 ) &&
+        ( DecompressString( OFFSET_TO_PSZ( desPPD.desItems.ofsExitserver, pInfoSeg), pScratch ) > 0 ))
+    {
+        printf("*ExitServer:            \"%s\"\n", pScratch );
+    }
+    if ( desPPD.desItems.ofsInitString >= 0 )
+        printf("*JCLBegin:              \"%s\"\n",
+                OffsetToProperCommand( desPPD.desItems.ofsInitString, pInfoSeg, pScratch ));
+    if ( desPPD.desItems.ofsJCLToPS >= 0 )
+        printf("*JCLToPSInterpreter:    \"%s\"\n",
+                OffsetToProperCommand( desPPD.desItems.ofsJCLToPS, pInfoSeg, pScratch ));
+    if ( desPPD.desItems.ofsTermString >= 0 )
+        printf("*JCLEnd:                \"%s\"\n",
+                OffsetToProperCommand( desPPD.desItems.ofsTermString, pInfoSeg, pScratch ));
+
+    //
+    // Halftone options
+    //
+    if ( desPPD.desItems.iScreenAngle > 0 )
+        printf("*ScreenAngle:           \"%.2f\"\n", desPPD.desItems.iScreenAngle / 100.0 );
+    if ( desPPD.desItems.lScrFreq > 0 )
+        printf("*ScreenFreq:            \"%.2f\"\n", desPPD.desItems.lScrFreq / 100.0 );
+    if (( desPPD.desItems.ofsTransferNor > 0 ) &&
+        ( DecompressString( OFFSET_TO_PSZ( desPPD.desItems.ofsTransferNor, pInfoSeg ), pScratch ) > 0 ))
+    {
+        printf("*Transfer Normalized:   \"%s\"\n", pScratch );
+    }
+    if (( desPPD.desItems.ofsTransferInv > 0 ) &&
+        ( DecompressString( OFFSET_TO_PSZ( desPPD.desItems.ofsTransferInv, pInfoSeg ), pScratch ) > 0 ))
+    {
+        printf("*Transfer Normalized.Inverse: \"%s\"\n", pScratch );
+    }
+    printf("\n");
+
+    //
+    // Page & media handling
+    //
+
+    /*
+    ** Find the PageSize UI block (every valid PPD should have one) and save a
+    ** pointer to it.  We'll need it at various points from here on down.
+    */
+    puiPaper = NULL;
+    puib = desPPD.stUIList.pBlockList;
+    for ( i = 0; !puiPaper && i < desPPD.stUIList.usBlockListSize; i++ ) {
+        psz = OFFSET_TO_PSZ( puib->ofsUIName, pInfoSeg );
+        if ( !strcmp( psz, "PageSize"))
+            puiPaper = puib;
+        INCREMENT_BLOCK_PTR( puib );
+    }
+    // Make note of the default value; this indicates the default paper size
+    if ( puiPaper && ( puiPaper->usNumOfEntries > puiPaper->usDefaultEntry ))
+        pszDefPage = OFFSET_TO_PSZ( puiPaper->uiEntry[puiPaper->usDefaultEntry].ofsOption, pInfoSeg );
+    else
+        pszDefPage = "Letter";
+
+    printf("*VariablePaperSize:     %s\n", (desPPD.desPage.fIsVariablePaper == 1) ? "True" : "False");
+
+    /*
+    ** The paper commands from desPage, plus everything in desInpbins, are
+    ** basically deprecated; these are all defined as UI items these days.
+    ** So we don't need to handle them (PIN doesn't write any of it into the
+    ** PAK file anyway).
+    ** The same goes for almost everything in desOutbins, but the following
+    ** do appear to be used to some extent.
+    */
+    printf("*DefaultOutputOrder:    %s\n", (desPPD.desOutbins.fIsDefoutorder == REVERSE)? "Reverse": "Normal");
+    if (( desPPD.desOutbins.ofsOrdernormal > 0 ) &&
+        ( DecompressString( OFFSET_TO_PSZ( desPPD.desOutbins.ofsOrdernormal, pInfoSeg ), pScratch ) > 0 ))
+    {
+        printf("*OutputOrder Normal:  \"%s\"\n", pScratch );
+    }
+    if (( desPPD.desOutbins.ofsOrderreverse > 0 ) &&
+        ( DecompressString( OFFSET_TO_PSZ( desPPD.desOutbins.ofsOrderreverse, pInfoSeg ), pScratch ) > 0 ))
+    {
+        printf("*OutputOrder Reverse: \"%s\"\n", pScratch );
+    }
+    // It's somewhat less clear, but desForms also seems to be unused nowadays.
+    printf("\n");
+
+    // desPage.ofsDefimagearea is unused; use pszDefPage instead
+    printf("*DefaultImageableArea: %s\n", pszDefPage );
+    psVal = (PSHORT)( pInfoSeg + desPPD.desPage.ofsImgblPgsz );
+    for ( i = 0; i < desPPD.desPage.iImgpgpairs; i++ ) {
+        pszName = NULL;
+        sIdx = (SHORT) *psVal;
+        psVal++;
+        sX1 = (SHORT) *psVal;       // lower left X
+        psVal++;
+        sY1 = (SHORT) *psVal;       // lower left Y
+        psVal++;
+        sX2 = (SHORT) *psVal;       // upper right X
+        psVal++;
+        sY2 = (SHORT) *psVal;       // upper right Y
+        psVal++;
+        pszXlate = (PSZ) psVal;     // translation string (if any)
+
+        // Get the actual form name from the *PageSize UI list
+        if ( puiPaper && ( puiPaper->usNumOfEntries > puiPaper->usDefaultEntry )) {
+            pszName = OFFSET_TO_PSZ( puiPaper->uiEntry[sIdx].ofsOption, pInfoSeg );
+            printf("*ImageableArea %s/%s: \"%d %d %d %d\"\n", pszName,
+                    (*pszXlate? pszXlate: pszName), sX1, sY1, sX2, sY2 );
+        }
+        psVal = (PSHORT) ((PSZ)( pszXlate + strlen( pszXlate ) + 1 ));
+    }
+    printf("\n");
+
+    // desPage.ofsDefpaperdim is also unused; again, use pszDefPage
+    printf("*DefaultPaperDimension: %s\n", pszDefPage );
+    psVal = (PSHORT)( pInfoSeg + desPPD.desPage.ofsDimxyPgsz );
+    for ( i = 0; i < desPPD.desPage.iDmpgpairs; i++ ) {
+        pszName = NULL;
+        sIdx = (SHORT) *psVal;
+        psVal++;
+        sX1 = (SHORT) *psVal;
+        psVal++;
+        sY1 = (SHORT) *psVal;
+        psVal++;
+
+        // Get the form name from the *PageSize UI list
+        if ( puiPaper && ( puiPaper->usNumOfEntries > puiPaper->usDefaultEntry )) {
+            pszName = OFFSET_TO_PSZ( puiPaper->uiEntry[sIdx].ofsOption, pInfoSeg );
+            pszXlate = ( puiPaper->uiEntry[sIdx].ofsTransString > 0 ) ?
+                         OFFSET_TO_PSZ( puiPaper->uiEntry[sIdx].ofsTransString, pInfoSeg ) :
+                         pszName;
+            printf("*PaperDimension %s/%s: \"%d %d\"\n", pszName, pszXlate, sX1, sY1 );
+        }
+    }
+    printf("\n");
+
+    if (( desPPD.desPage.ofsCustomPageSize > 0 ) &&
+        ( DecompressString( OFFSET_TO_PSZ( desPPD.desPage.ofsCustomPageSize, pInfoSeg ), pScratch ) > 0 ))
+    {
+        printf("*CustomPageSize True: \"%s\"\n", pScratch );
+        /*
+        ** We have to hardcode the order because the PAK file doesn't contain
+        ** that information.  It's missing a couple of supposedly-required
+        ** parameters as well, but there's nothing we can do about that either.
+        ** Anyway, if they're not in the PAK file, the PS driver obviously
+        ** doesn't need/use them in any case.
+        */
+        printf("*ParamCustomPageSize Width: 1 points %d %d\n",
+                desPPD.desPage.iCustomPageSizeMinWidth,
+                desPPD.desPage.iCustomPageSizeMaxWidth );
+        printf("*ParamCustomPageSize Height: 2 points %d %d\n",
+                desPPD.desPage.iCustomPageSizeMinHeight,
+                desPPD.desPage.iCustomPageSizeMaxHeight );
+        printf("\n");
+    }
+
+    //
+    // Write out the UI constraints, if any
+    //
+    puicb = desPPD.stUICList.puicBlockList;
+    for ( i = 0; puicb && i < desPPD.stUICList.usNumOfUICs; i++ ) {
+        PSZ pszName1, pszName2,
+            pszVal1, pszVal2;
+        PUI_BLOCK puib2;
+
+        puib = desPPD.stUIList.pBlockList;
+        for ( j = 0; j < puicb->uicEntry1.ofsUIBlock; j++ )
+            INCREMENT_BLOCK_PTR( puib );
+        pszName1 = OFFSET_TO_PSZ( puib->ofsUIName, pInfoSeg );
+        if ( puicb->uicEntry1.bOption ) {
+            for ( j = 0; j < 32 && j < puib->usNumOfEntries; j++ ) {
+                if (( puicb->uicEntry1.bOption >> j ) & 1 ) {
+                    pszVal1 = OFFSET_TO_PSZ( puib->uiEntry[j].ofsOption, pInfoSeg );
+                    puib2 = desPPD.stUIList.pBlockList;
+                    for ( k = 0; k < puicb->uicEntry2.ofsUIBlock; k++ )
+                        INCREMENT_BLOCK_PTR( puib2 );
+                    pszName2 = OFFSET_TO_PSZ( puib2->ofsUIName, pInfoSeg );
+                    if ( puicb->uicEntry2.bOption ) {
+                        for ( k = 0; k < 32 && k < puib2->usNumOfEntries; k++ ) {
+                            if (( puicb->uicEntry2.bOption >> k ) & 1 ) {
+                                pszVal2 = OFFSET_TO_PSZ( puib2->uiEntry[k].ofsOption, pInfoSeg );
+                                printf("*UIConstraints: *%s %s *%s %s\n",
+                                        pszName1, pszVal1, pszName2, pszVal2 );
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        puicb++;
+    }
+    printf("\n");
+
+    //
+    // OK, now do the UI items
+    //
+    puib = desPPD.stUIList.pBlockList;
+    for ( i = 0; puib && desPPD.stUIList.usBlockListSize && i < desPPD.stUIList.usNumOfBlocks; i++ ) {
+        psz = OFFSET_TO_PSZ( puib->ofsUIName, pInfoSeg );
+
+        printf("*OpenUI *%s/%s: ", psz,
+                OFFSET_TO_PSZ( puib->ofsUITransString, pInfoSeg ));
+        switch( puib->usSelectType ) {
+            case UI_SELECT_BOOLEAN : printf("Boolean\n");  break;
+            case UI_SELECT_PICKMANY: printf("PickMany\n"); break;
+            case UI_SELECT_PICKONE :
+            default                : printf("PickOne\n");  break;
+        }
+
+        // Write the order dependency line
+        printf("*OrderDependency: %d ", puib->usOrderDep + 1 );
+        switch( puib->usUILocation ) {
+            default:
+            case UI_ORDER_ANYSETUP   : printf("AnySetup ");      break;
+            case UI_ORDER_JCLSETUP   : printf("JCLSetup ");      break;
+            case UI_ORDER_PAGESETUP  : printf("PageSetup ");     break;
+            case UI_ORDER_DOCSETUP   : printf("DocumentSetup "); break;
+            case UI_ORDER_PROLOGSETUP: printf("Prolog ");        break;
+            case UI_ORDER_EXITSERVER : printf("ExitServer ");    break;
+        }
+        printf("*%s\n", psz );
+
+        if ( strcmp( psz, "PageSize") == 0 ) {
+            // We already saved the default, no need to jump through hoops now
+            pszDefault = pszDefPage;
+        }
+        else if ( strcmp( psz, "Resolution") == 0 ) {
+            // Try a few different ways to determine the default resolution
+            if ( puib->usNumOfEntries > puib->usDefaultEntry )
+                pszDefault = OFFSET_TO_PSZ( puib->uiEntry[puib->usDefaultEntry].ofsOption, pInfoSeg );
+            else if ( desPPD.desItems.iResDpi > 0 ) {
+                sprintf( pScratch, "%ddpi", desPPD.desItems.iResDpi );
+                pszDefault = pScratch;
+            }
+            else if ( puib->usNumOfEntries )
+                pszDefault = OFFSET_TO_PSZ( puib->uiEntry[0].ofsOption, pInfoSeg );
+            else
+                pszDefault = "300dpi";
+        }
+        else {
+            // Find the default; if there's no default, just use the first item
+            if ( puib->usNumOfEntries > puib->usDefaultEntry )
+                pszDefault = OFFSET_TO_PSZ( puib->uiEntry[puib->usDefaultEntry].ofsOption, pInfoSeg );
+            else if ( puib->usNumOfEntries )
+                pszDefault = OFFSET_TO_PSZ( puib->uiEntry[0].ofsOption, pInfoSeg );
+            else
+                pszDefault = "Unknown";     // hopefully shouldn't happen
+        }
+        printf("*Default%s: %s\n", psz, pszDefault );
+
+        // Now write the list of actual values
+        for ( j = 0; j < puib->usNumOfEntries; j++ ) {
+            pszName = OFFSET_TO_PSZ( puib->uiEntry[j].ofsOption, pInfoSeg );
+            pszXlate = ( puib->uiEntry[j].ofsTransString > 0 ) ?
+                       OFFSET_TO_PSZ( puib->uiEntry[j].ofsTransString, pInfoSeg ) :
+                       pszName;
+            printf("*%s %s/%s: ", psz, pszName, pszXlate );
+            if (( puib->uiEntry[j].ofsValue > 0 ) &&
+                ( DecompressString( OFFSET_TO_PSZ( puib->uiEntry[j].ofsValue, pInfoSeg ), pScratch ) > 0 ))
+            {
+                printf("\"%s\"\n", pScratch );
+            } else
+                printf("\"\"\n");
+        }
+
+        // Do we need to do anything with this?
+        // puib->ucGroupType
+
+        printf("*CloseUI: *%s\n", psz );
+        printf("\n");
+        INCREMENT_BLOCK_PTR( puib );
+    }
+
+    //
+    // Lastly, the supported hardware fonts
+    //
+    if ( desPPD.desFonts.ofsDeffont > 0 )
+        printf("*DefaultFont: %s\n", OFFSET_TO_PSZ( desPPD.desFonts.ofsDeffont, pInfoSeg ));
+    psz = OFFSET_TO_PSZ( desPPD.desFonts.ofsFontnames, pInfoSeg );
+    for ( i = 0; (i < desPPD.desFonts.iFonts) && *psz; i++ ) {
+        // Just use some common values for the encoding/version/status; PIN
+        // doesn't use or care about them anyway.
+        printf("*Font %s: Standard \"(001.006S)\" Standard ROM\n", psz );
+        psz += strlen( psz ) + 1;
+    }
+    printf("\n");
+
+    // And we're done!
+
+    // Clean up
+    free( desPPD.stUIList.pBlockList );
+    free( desPPD.stUICList.puicBlockList );
+    free( pScratch );
+}
+
+
+//
+// THESE FUNCTIONS STOLEN FROM UTLCHNL.C (USED FOR DECOMPRESSING STRINGS):
+//
+
+//*****************************************************************************
+//
+// FUNCTION: CharToHex
+//
+// DESCRIPTION: Converts an character to its hex rep
+//
+// Returns -1 if fails
+//
+//*****************************************************************************
+
+BYTE CharToHex( CHAR c )
+{
+  if ( c >= '0' && c <= '9' )
+  {
+    return c - '0';
+  }
+  else
+  if ( c >= 'a' && c <= 'f' )
+  {
+    return c - 'a' + 10;
+  }
+  if ( c >= 'A' && c <= 'F' )
+  {
+    return c - 'A' + 10;
+  }
+
+  return -1;
+}
+
+//*****************************************************************************
+//
+// FUNCTION: ProcessHexString
+//
+// DESCRIPTION: Will take a WELL FORMED hex string that is one that starts
+// with less than char, is all hex digits - no white space, and even amount
+// ending with greater than char
+// Note - since function will adjust the callers in and out buffers the addr
+// of the callers buufers are passesd hence the PSZ * type
+//
+// Defect 203803 some strings are not up to standards eg HP 1200C where they are
+// in form <a><b> ....
+// So we have to take that in account (Real World - you know)
+//
+// RETURNS:
+// Returns the number of hex bytes - esentially the number of ASCII chars/2 -
+// 2 for the <>
+//
+//*****************************************************************************
+
+SHORT ProcessHexString( PSZ *ppszBuffIn,  // Ptr 2 Ptr of input buffer
+                        PSZ *ppszBuffOut) // Ptr 2 Ptr of output buffer
+{
+  PSZ pIn  = *ppszBuffIn;
+  PSZ pOut = *ppszBuffOut;
+  INT iCount = 0;
+
+  // Hop over initial < of hex string
+  *pIn++;
+
+  while ( *pIn != '>' )
+  {
+    *pOut = CharToHex( *pIn );
+    pIn++;
+    //-------------------- Georgs P.         203803
+    if ( *pIn != '>' )
+    {
+      *pOut = (*pOut << 4) | CharToHex( *pIn );
+      pIn++;
+    }
+    pOut++;
+    iCount++;
+  }
+
+  // Adjust pointers
+  *ppszBuffIn = pIn;
+  *ppszBuffOut = pOut;
+
+  return iCount;
+}
+
+
+/*****************************************************************************\
+**
+** FUNCTION NAME = DecompressString
+**
+** DESCRIPTION   = Decompress a string from ppd files that was
+**                 compressed by the PPD compiler.
+**
+**
+** INPUT         = pszBuffIn                - pointer to input buffer
+**                 pszBuffOut               - pointer to output buffer
+**
+** OUTPUT        = returns length of output buffer
+**
+** RETURN-NORMAL = NONE
+** RETURN-ERROR  = NONE
+**
+\*****************************************************************************/
+
+USHORT DecompressString(PSZ pszBuffIn, PSZ pszBuffOut)
+{
+  SHORT  sAdjust;
+  USHORT usIndex;
+  SHORT  usOutSize;                     /* size of the output buffer    */
+  USHORT usStringLen;
+  USHORT usOffSet;
+
+  usOutSize = 0;
+
+  /*
+  ** For each char in source
+  */
+  while ( *pszBuffIn )
+  {
+
+    // Ahh - must be either a hex string or dict entry
+    if ( *pszBuffIn == '<' )
+    {
+      // Another < - must be dict entry
+      // Add them to output line
+      if ( *(pszBuffIn+1) == '<' )
+      {
+        *pszBuffOut++ = *pszBuffIn++;
+        *pszBuffOut++ = *pszBuffIn;
+        usOutSize += 2;
+      }
+      else
+      {
+        /*        ** "cng55p2.ppd" [UIsection=Halftone]; "601ps95.ppd [UIsection=Collate]"
+        */
+        if ( *(pszBuffIn+1) == ' '  || *(pszBuffIn+1) == '\n' ||
+             *(pszBuffIn+1) == '\r' || *(pszBuffIn+1) == '\t' )
+        {
+           *pszBuffOut++ = *pszBuffIn;
+           usOutSize++;
+        }
+        else
+        {
+          usOutSize += ProcessHexString( &pszBuffIn, &pszBuffOut );
+        }
+      }
+    }
+    else
+    if (*pszBuffIn < 128)  //If regular character copy it over
+    {
+      *pszBuffOut = *pszBuffIn;
+      usOutSize++;
+      pszBuffOut++;
+    }
+    else          //Its a compressed char
+    {
+      sAdjust = -128;
+      while (*pszBuffIn == 255) //Pass over flag bytes
+      {
+        pszBuffIn++;
+        sAdjust += 254;         //This is the offset adjust
+      }
+      usIndex = (USHORT)*pszBuffIn + sAdjust; //This is the postion of offset
+      usOffSet = sPSKeyWordOffset[usIndex];   //Actual offset into words buffer
+      strcpy(pszBuffOut,&(achPSKeyWords[usOffSet]));  //Copy word to target
+      usStringLen = strlen (&(achPSKeyWords[usOffSet]));
+      usOutSize += usStringLen;  //Adjust pointers
+      pszBuffOut += usStringLen;
+    }
+    pszBuffIn++;
+  }
+  *pszBuffOut = '\0';   //End with null byte
+  return(usOutSize);
+}
+
+
+
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/pinmain.c src\osdd\pscript\psprint/pin/pinmain.c
--- src\osdd\pscript\post32/pin/pinmain.c	Tue Nov 11 18:10:52 2003
+++ src\osdd\pscript\psprint/pin/pinmain.c	Wed Nov 24 17:25:54 2010
@@ -51,6 +51,10 @@
 #include "afm2pak.h"
 #include "ppd2ppb.h"
 
+#ifdef __KLIBC__
+	#define strcmpi strcmp
+#endif
+
 //
 //
 //
@@ -160,8 +164,10 @@
    // disable output buffering
    setvbuf( stdout, NULL, _IONBF, 0 );
 
-   printf("PostScript resource packaging utility version 1.00\n");
+   // Increment version to 1.20  -- ALT_CUPS  2010-11-21
+   printf("PostScript resource packaging utility version 1.20\n");
    printf("Copyright (c) IBM Corp. 2000,2001. All rights reserved.\n\n");
+   printf("Copyright (c) netlabs.org 2007,2010. All rights reserved.\n\n");
 
    // parse the command line
 
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/ppd2bin.h src\osdd\pscript\psprint/pin/ppd2bin.h
--- src\osdd\pscript\post32/pin/ppd2bin.h	Tue Nov 11 18:12:56 2003
+++ src\osdd\pscript\psprint/pin/ppd2bin.h	Wed Dec  8 15:24:50 2010
@@ -113,6 +113,8 @@
   JCLOpenUI,
   CustomPageSize,                                              
   ParamCustomPageSize,                                         
+//  CupsRes,              /* StpQuality    --  ALT_CUPS */
+  TTRasterizer,         /* TTRasterizer  --  ALT_CUPS */
   maximum
 } ;
 
@@ -179,7 +181,9 @@
   "*UIConstraints",
   "*JCLOpenUI",
   "*CustomPageSize",                                          
-  "*ParamCustomPageSize"                                      
+  "*ParamCustomPageSize",
+//  "*StpQuality",                 /* ALT_CUPS */
+  "*TTRasterizer"                /* ALT_CUPS */
 } ;
 
 /*
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/ppdenc.c src\osdd\pscript\psprint/pin/ppdenc.c
--- src\osdd\pscript\post32/pin/ppdenc.c	Tue Nov 11 18:10:54 2003
+++ src\osdd\pscript\psprint/pin/ppdenc.c	Fri Dec 17 15:54:24 2010
@@ -36,6 +36,14 @@
  *
  * EXTERNAL FUNCTIONS
  *
+ * CHANGES
+ * alt: Prevent the modified LanguageEncoding string from overwriting part of
+ *      the next line if the old string is shorter than the new one
+ * alt: Added MacStandard support; also removed the redundant UTF-8 table,
+ *      as we can just use the ISOLatin table for UTF-8 directly
+ * bvl: Added UTF-8 Support, we simply substitute the ISOLatin table for it,
+ *      supposedly the first 256 chars of UTF are ISOLatin, it at least
+ *      solves our problems
 */
 
 
@@ -54,8 +62,12 @@
 #define CONVERT_ISOLATIN1      0
 #define CONVERT_WINDOWSANSI    1
 #define CONVERT_MAC            2
+#define CONVERT_UTF8           3
 #define CONVERT_UNKNOWN        1000
 
+char os2cp_str[] = "*LanguageEncoding: OS2-850\n";
+char *cpfull_ptr;       // pointer to the above string in the global buffer
+char *cpstr_ptr;        // pointer to just the value portion of the above string
 
 char *MRI_LANG = NULL;
 
@@ -77,9 +89,10 @@
 // charset conversion tables
 
 
+// ISOLatin1 and UTF8 to Ibm850
 char FromIso[256] =
 {
-  /* Code */ /* source character name */  /* destionation code */
+  /* Code */ /* source character name */  /* destination code */
   /*   0  */ /* -unused- */                  0x00,
   /*   1  */ /* -unused- */                  0x01,
   /*   2  */ /* -unused- */                  0x02,
@@ -343,6 +356,269 @@
 };
 
 
+// MacStandard to Ibm850
+char FromMac[256] =
+{
+  /* Code */ /* source character name */  /* destination code */
+  /*   0  */ /* -unused- */                  0x00,
+  /*   1  */ /* -unused- */                  0x01,
+  /*   2  */ /* -unused- */                  0x02,
+  /*   3  */ /* -unused- */                  0x03,
+  /*   4  */ /* -unused- */                  0x04,
+  /*   5  */ /* -unused- */                  0x05,
+  /*   6  */ /* -unused- */                  0x06,
+  /*   7  */ /* -unused- */                  0x07,
+  /*   8  */ /* -unused- */                  0x08,
+  /*   9  */ /* -unused- */                  0x09,
+  /*  10  */ /* -unused- */                  0x0A,
+  /*  11  */ /* -unused- */                  0x0B,
+  /*  12  */ /* -unused- */                  0x0C,
+  /*  13  */ /* -unused- */                  0x0D,
+  /*  14  */ /* -unused- */                  0x0E,
+  /*  15  */ /* -unused- */                  0x0F,
+  /*  16  */ /* -unused- */                  0x10,
+  /*  17  */ /* -unused- */                  0x11,
+  /*  18  */ /* -unused- */                  0x12,
+  /*  19  */ /* -unused- */                  0x13,
+  /*  20  */ /* -unused- */                  0x14,
+  /*  21  */ /* -unused- */                  0x15,
+  /*  22  */ /* -unused- */                  0x16,
+  /*  23  */ /* -unused- */                  0x17,
+  /*  24  */ /* -unused- */                  0x18,
+  /*  25  */ /* -unused- */                  0x19,
+  /*  26  */ /* -unused- */                  0x1A,
+  /*  27  */ /* -unused- */                  0x1B,
+  /*  28  */ /* -unused- */                  0x1C,
+  /*  29  */ /* -unused- */                  0x1D,
+  /*  30  */ /* -unused- */                  0x1E,
+  /*  31  */ /* -unused- */                  0x1F,
+  /*  32  */ /* space */                     0x20,
+  /*  33  */ /* exclam */                    0x21,
+  /*  34  */ /* quotedbl */                  0x22,
+  /*  35  */ /* numbersign */                0x23,
+  /*  36  */ /* dollar */                    0x24,
+  /*  37  */ /* percent */                   0x25,
+  /*  38  */ /* ampersand */                 0x26,
+  /*  39 x*/ /* quoteright */                0x27,
+  /*  40  */ /* parenleft */                 0x28,
+  /*  41  */ /* parenright */                0x29,
+  /*  42  */ /* asterisk */                  0x2A,
+  /*  43  */ /* plus */                      0x2B,
+  /*  44  */ /* comma */                     0x2C,
+  /*  45 x*/ /* minus */                     0x2D,
+  /*  46  */ /* period */                    0x2E,
+  /*  47  */ /* slash */                     0x2F,
+  /*  48  */ /* zero */                      0x30,
+  /*  49  */ /* one  */                      0x31,
+  /*  50  */ /* two */                       0x32,
+  /*  51  */ /* three */                     0x33,
+  /*  52  */ /* four */                      0x34,
+  /*  53  */ /* five */                      0x35,
+  /*  54  */ /* six */                       0x36,
+  /*  55  */ /* seven */                     0x37,
+  /*  56  */ /* eight */                     0x38,
+  /*  57  */ /* nine */                      0x39,
+  /*  58  */ /* colon */                     0x3A,
+  /*  59  */ /* semicolon */                 0x3B,
+  /*  60  */ /* less */                      0x3C,
+  /*  61  */ /* equal */                     0x3D,
+  /*  62  */ /* greater */                   0x3E,
+  /*  63  */ /* question */                  0x3F,
+  /*  64  */ /* at */                        0x40,
+  /*  65  */ /* A */                         0x41,
+  /*  66  */ /* B */                         0x42,
+  /*  67  */ /* C */                         0x43,
+  /*  68  */ /* D */                         0x44,
+  /*  69  */ /* E */                         0x45,
+  /*  70  */ /* F */                         0x46,
+  /*  71  */ /* G */                         0x47,
+  /*  72  */ /* H */                         0x48,
+  /*  73  */ /* I */                         0x49,
+  /*  74  */ /* J */                         0x4A,
+  /*  75  */ /* K */                         0x4B,
+  /*  76  */ /* L */                         0x4C,
+  /*  77  */ /* M */                         0x4D,
+  /*  78  */ /* N */                         0x4E,
+  /*  79  */ /* O */                         0x4F,
+  /*  80  */ /* P */                         0x50,
+  /*  81  */ /* Q */                         0x51,
+  /*  82  */ /* R */                         0x52,
+  /*  83  */ /* S */                         0x53,
+  /*  84  */ /* T */                         0x54,
+  /*  85  */ /* U */                         0x55,
+  /*  86  */ /* V */                         0x56,
+  /*  87  */ /* W */                         0x57,
+  /*  88  */ /* X */                         0x58,
+  /*  89  */ /* Y */                         0x59,
+  /*  90  */ /* Z */                         0x5A,
+  /*  91  */ /* bracketleft */               0x5B,
+  /*  92  */ /* backslash */                 0x5C,
+  /*  93  */ /* bracketright */              0x5D,
+  /*  94  */ /* asciicircum */               0x5E,
+  /*  95  */ /* underscore */                0x5F,
+  /*  96 x*/ /* quoteleft */                 0x60,
+  /*  97  */ /* a */                         0x61,
+  /*  98  */ /* b */                         0x62,
+  /*  99  */ /* c */                         0x63,
+  /* 100  */ /* d */                         0x64,
+  /* 101  */ /* e */                         0x65,
+  /* 102  */ /* f */                         0x66,
+  /* 103  */ /* g */                         0x67,
+  /* 104  */ /* h */                         0x68,
+  /* 105  */ /* i */                         0x69,
+  /* 106  */ /* j */                         0x6A,
+  /* 107  */ /* k */                         0x6B,
+  /* 108  */ /* l */                         0x6C,
+  /* 109  */ /* m */                         0x6D,
+  /* 110  */ /* n */                         0x6E,
+  /* 111  */ /* o */                         0x6F,
+  /* 112  */ /* p */                         0x70,
+  /* 113  */ /* q */                         0x71,
+  /* 114  */ /* r */                         0x72,
+  /* 115  */ /* s */                         0x73,
+  /* 116  */ /* t */                         0x74,
+  /* 117  */ /* u */                         0x75,
+  /* 118  */ /* v */                         0x76,
+  /* 119  */ /* w */                         0x77,
+  /* 120  */ /* x */                         0x78,
+  /* 121  */ /* y */                         0x79,
+  /* 122  */ /* z */                         0x7A,
+  /* 123  */ /* braceleft */                 0x7B,
+  /* 124  */ /* bar */                       0x7C,
+  /* 125  */ /* braceright */                0x7D,
+  /* 126  */ /* asciitilde */                0x7E,
+  /* 127  */ /* -unused- */                  0x7F,
+  /* 128  */ /* Adieresis */                 0x8E,
+  /* 129  */ /* Aring */                     0x8F,
+  /* 130  */ /* Ccedilla */                  0x80,
+  /* 131  */ /* Eacute */                    0x90,
+  /* 132  */ /* Ntilde */                    0xA5,
+  /* 133  */ /* Odieresis */                 0x99,
+  /* 134  */ /* Udieresis */                 0x9A,
+  /* 135  */ /* aacute */                    0xA0,
+  /* 136  */ /* agrave */                    0x85,
+  /* 137  */ /* acircumflex */               0x83,
+  /* 138  */ /* adieresis */                 0x84,
+  /* 139  */ /* atilde */                    0xC6,
+  /* 140  */ /* aring */                     0x86,
+  /* 141  */ /* ccedilla */                  0x87,
+  /* 142  */ /* eacute */                    0x82,
+  /* 143  */ /* egrave */                    0x8A,
+  /* 144  */ /* ecircumflex */               0x88,
+  /* 145  */ /* edieresis */                 0x89,
+  /* 146  */ /* iacute */                    0xA1,
+  /* 147  */ /* igrave */                    0x8D,
+  /* 148  */ /* icircumflex */               0x8C,
+  /* 149  */ /* idieresis */                 0x8B,
+  /* 150  */ /* ntilde */                    0xA4,
+  /* 151  */ /* oacute */                    0xA2,
+  /* 152  */ /* ograve */                    0x95,
+  /* 153  */ /* ocircumflex */               0x93,
+  /* 154  */ /* odieresis */                 0x94,
+  /* 155  */ /* otilde */                    0xE4,
+  /* 156  */ /* uacute */                    0xA3,
+  /* 157  */ /* ugrave */                    0x97,
+  /* 158  */ /* ucircumflex */               0x96,
+  /* 159  */ /* udieresis */                 0x81,
+  /* 160  */ /* dagger */                    0x7F,  // not present
+  /* 161  */ /* degree */                    0xF8,
+  /* 162  */ /* cent */                      0xBD,
+  /* 163  */ /* sterling */                  0x9C,
+  /* 164  */ /* section */                   0xF5,
+  /* 165  */ /* bullet */                    0x07,
+  /* 166  */ /* paragraph */                 0xF4,
+  /* 167  */ /* germandbls */                0xE1,
+  /* 168  */ /* registered */                0xA9,
+  /* 169  */ /* copyright */                 0xB8,
+  /* 170  */ /* trademark */                 0x7F,  // not present
+  /* 171  */ /* acute */                     0xEF,
+  /* 172  */ /* dieresis */                  0xF9,
+  /* 173  */ /* notequal */                  0x7F,  // not present
+  /* 174  */ /* AE */                        0x92,
+  /* 175  */ /* Oslash */                    0x9D,
+  /* 176  */ /* infinity */                  0x7F,  // not present
+  /* 177  */ /* plusminus */                 0xF1,
+  /* 178  */ /* lessequal */                 0x7F,  // not present
+  /* 179  */ /* greaterequal */              0x7F,  // not present
+  /* 180  */ /* yen */                       0xBE,
+  /* 181  */ /* mu */                        0xE6,
+  /* 182  */ /* partialdiff */               0x7F,  // not present
+  /* 183  */ /* summation */                 0x7F,  // not present
+  /* 184  */ /* product */                   0x7F,  // not present
+  /* 185  */ /* pi */                        0x7F,  // not present
+  /* 186  */ /* integral */                  0x7F,  // not present
+  /* 187  */ /* ordfeminine */               0xA6,
+  /* 188  */ /* ordmasculine */              0xA7,
+  /* 189  */ /* Omega */                     0x7F,  // not present
+  /* 190  */ /* ae */                        0x91,
+  /* 191  */ /* oslash */                    0x9B,
+  /* 192  */ /* questiondown */              0xA8,
+  /* 193  */ /* exclamdown */                0xAD,
+  /* 194  */ /* logicalnot */                0xAA,
+  /* 195  */ /* radical */                   0x7F,  // not present
+  /* 196  */ /* florin */                    0x9F,
+  /* 197  */ /* approxequal */               0x7F,  // not present
+  /* 198  */ /* Delta */                     0x7F,  // not present
+  /* 199  */ /* guillemotleft */             0xAE,
+  /* 200  */ /* guillemotright */            0xAF,
+  /* 201  */ /* ellipsis */                  0x7F,  // not present
+  /* 202  */ /* space */                     0x20,
+  /* 203  */ /* Agrave */                    0xB7,
+  /* 204  */ /* Atilde */                    0xC7,
+  /* 205  */ /* Otilde */                    0xE5,
+  /* 206  */ /* OE */                        0x7F,  // not present
+  /* 207  */ /* oe */                        0x7F,  // not present
+  /* 208  */ /* endash */                    0x2D,  // simulate w/hyphen
+  /* 209  */ /* emdash */                    0x2D,  // simulate w/hyphen
+  /* 210  */ /* quotedblleft */              0x22,  // simulate w/dblquote
+  /* 211  */ /* quotedblright */             0x22,  // simulate w/dblquote
+  /* 212  */ /* quoteleft */                 0x96,  // simulate w/grave
+  /* 213  */ /* quoteright */                0x39,  // simulate w/apostrophe
+  /* 214  */ /* divide */                    0xF6,
+  /* 215  */ /* lozenge */                   0x7F,  // not present
+  /* 216  */ /* ydieresis */                 0x98,
+  /* 217  */ /* Ydieresis */                 0x7F,  // not present
+  /* 218  */ /* fraction */                  0x7F,  // not present
+  /* 219  */ /* currency */                  0xCF,
+  /* 220  */ /* guilsinglleft */             0x7F,  // not present
+  /* 221  */ /* guilsinglright */            0x7F,  // not present
+  /* 222  */ /* fi */                        0x7F,  // not present
+  /* 223  */ /* fl */                        0x7F,  // not present
+  /* 224  */ /* daggerdbl */                 0x7F,  // not present
+  /* 225  */ /* periodcentered */            0xFA,
+  /* 226  */ /* quotesinglbase */            0x2C,  // simulate w/comma
+  /* 227  */ /* quotedblbase */              0x7F,  // not present
+  /* 228  */ /* perthousand */               0x7F,  // not present
+  /* 229  */ /* Acircumflex */               0x86,
+  /* 230  */ /* Ecircumflex */               0xD2,
+  /* 231  */ /* Aacute */                    0xB5,
+  /* 232  */ /* Edieresis */                 0xD3,
+  /* 233  */ /* Egrave */                    0xD4,
+  /* 234  */ /* Iacute */                    0xD6,
+  /* 235  */ /* Icircumflex */               0xD7,
+  /* 236  */ /* Idieresis */                 0xD8,
+  /* 237  */ /* Igrave */                    0xDE,
+  /* 238  */ /* Oacute */                    0xE0,
+  /* 239  */ /* Ocircumflex */               0xE2,
+  /* 240  */ /* apple */                     0x7F,  // not present
+  /* 241  */ /* Ograve */                    0xE3,
+  /* 242  */ /* Uacute */                    0xE9,
+  /* 243  */ /* Ucircumflex */               0xEA,
+  /* 244  */ /* Ugrave */                    0xEB,
+  /* 245  */ /* dotlessi */                  0x7F,  // not present anymore
+  /* 246  */ /* circumflex */                0x5E,
+  /* 247  */ /* tilde */                     0x7E,
+  /* 248  */ /* macron */                    0xEE,
+  /* 249  */ /* breve */                     0x7F,  // not present
+  /* 250  */ /* dotaccent */                 0x7F,  // not present
+  /* 251  */ /* ring */                      0xF8,  // simulate w/degree
+  /* 252  */ /* cedilla */                   0xF7,
+  /* 253  */ /* hungarumlaut */              0x7F,  // not present
+  /* 254  */ /* ogonek */                    0x7F,  // not present
+  /* 255  */ /* caron */                     0x7F   // not present
+};
+
+
 // WindowsAnsi to Ibm850
 char FromWindows[256] =
 {
@@ -640,8 +916,12 @@
 
     if( iSrcCharset == CONVERT_ISOLATIN1 )
        convtab = FromIso;
+    else if( iSrcCharset == CONVERT_MAC )
+       convtab = FromMac;
     else if( iSrcCharset == CONVERT_WINDOWSANSI )
        convtab = FromWindows;
+    else if( iSrcCharset == CONVERT_UTF8 )
+       convtab = FromIso;
     else
     {
         // just copy over the data and pretend it's OK
@@ -815,7 +1095,7 @@
     buf_size = ftell( in );
     fseek( in, 0L, SEEK_SET);
 
-    buf = malloc ( buf_size + 4 ); // 4 kb
+    buf = calloc( buf_size + 4 + strlen(os2cp_str) + 1, sizeof(char) );  // alt
     if( buf == NULL )
     {
         printf("  out of memory reading input file (asked for %d bytes)\n", buf_size );
@@ -874,6 +1154,12 @@
         }
     }
 
+    // ALT  Put the OS/2 cp string in a constant (unused) space at the end of
+    //      the buffer.  That way we can just move the pointer to it instead
+    //      of overwriting (and possibly overrunning) the existing string.
+    cpfull_ptr = buf + buf_size + 4;
+    strcpy( cpfull_ptr, os2cp_str );
+    cpstr_ptr = cpfull_ptr + strlen("*LanguageEncoding:");
 
     PpdBuf = buf;
 
@@ -892,7 +1178,6 @@
     char key[19] = "*LanguageEncoding:";
     char word[19] = "";
     int  enc_offset;
-    char os2cp_str[] = " OS2-850\r\n";
 
     for( node = list_head ; node != NULL ; node = node->pNext )
     {
@@ -937,8 +1222,21 @@
                 iCharset = CONVERT_ISOLATIN1;
                 printf( "(IsoLatin1)" );
 
-                strcpy( &str[ enc_offset ], os2cp_str );
-                node->iStrSize = enc_offset + strlen( os2cp_str );
+//                strcpy( &str[ enc_offset ], os2cp_str );
+//                node->iStrSize = enc_offset + strlen( os2cp_str ) - 1;
+                node->pStr = cpfull_ptr;
+                node->iStrSize = strlen( os2cp_str );
+                break;
+            }
+            else if( !stricmp( word, "MacStandard") )
+            {
+                iCharset = CONVERT_MAC;
+                printf( "(MacStandard)" );
+
+//                strcpy( &str[ enc_offset ], os2cp_str );
+//                node->iStrSize = enc_offset + strlen( os2cp_str ) - 1;
+                node->pStr = cpfull_ptr;
+                node->iStrSize = strlen( os2cp_str );
                 break;
             }
             else if( !stricmp( word, "WindowsANSI") )
@@ -946,13 +1244,26 @@
                 iCharset = CONVERT_WINDOWSANSI;
                 printf( "(WindowsAnsi)" );
 
-                strcpy( &str[ enc_offset ], os2cp_str );
-                node->iStrSize = enc_offset + strlen( os2cp_str ) - 1;
+//                strcpy( &str[ enc_offset ], os2cp_str );
+//                node->iStrSize = enc_offset + strlen( os2cp_str ) - 1;
+                node->pStr = cpfull_ptr;
+                node->iStrSize = strlen( os2cp_str );
+                break;
+            }
+            else if( !stricmp( word, "UTF-8") )
+            {
+                iCharset = CONVERT_UTF8;
+                printf( "(UTF-8)" );
+
+//                strcpy( &str[ enc_offset ], os2cp_str );
+//                node->iStrSize = enc_offset + strlen( os2cp_str ) - 1;
+                node->pStr = cpfull_ptr;
+                node->iStrSize = strlen( os2cp_str );
                 break;
             }
-            else if( !stricmp( word, os2cp_str ) )
+            else if( !stricmp( word, cpstr_ptr ) )
             {
-                printf( "(%s already)", os2cp_str );
+                printf( "(%s already)", cpstr_ptr );
                 break;
             }
             else
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/pt_struct.h src\osdd\pscript\psprint/pin/pt_struct.h
--- src\osdd\pscript\post32/pin/pt_struct.h	Thu Jan  1 00:00:00 1970
+++ src\osdd\pscript\psprint/pin/pt_struct.h	Fri May 30 11:57:08 2014
@@ -0,0 +1,434 @@
+/*DDK*************************************************************************/
+/*                                                                           */
+/* COPYRIGHT    Copyright (C) 1991, 2003 IBM Corporation                     */
+/*                                                                           */
+/*    The following IBM OS/2 source code is provided to you solely for       */
+/*    the purpose of assisting you in your development of OS/2 device        */
+/*    drivers. You may use this code in accordance with the IBM License      */
+/*    Agreement provided in the IBM Developer Connection Device Driver       */
+/*    Source Kit for OS/2. This Copyright statement may not be removed.      */
+/*                                                                           */
+/*****************************************************************************/
+/****************************************************************************/
+/* Modified version of struct.h for use by PAKTOOL                          */
+/*                                                                          */
+/****************************************************************************/
+
+#define  ALLPPDS       450
+#define  DIRECTORY_PPB 1
+#define  TRUE          1
+#define  FALSE         0
+#define  NONE          -1
+#define  BANNER        0
+#define  NOBANNER      1
+#define  NORMAL        0
+#define  REVERSE       1
+#define  PORTRAIT      0
+#define  LANDSCAPE     1
+#define  CNFRES        0
+#define  PPDRES        1
+#define  RESBUF        2
+#define  SGNRES        3
+#define  DIRRES        4
+#define  LCLRES        5
+#define  IMAXRES       5
+#define  SYSTEM        0
+#define  RAW           1
+#define  ENCAPS        2
+#define  ATRAY         0
+#define  BTRAY         1
+#define  CTRAY         2
+#define  DTRAY         3
+#define  ETRAY         4
+#define  MANUAL        5     /* treated as the last tray                    */
+#define  MAX_FNAMESIZE 40    /* Maximum size of a file name                 */
+/*
+** Increase MAX_INPUT from 256 to 512 to allow for more PPD files.
+*/
+#define  MAX_INPUT     512   /* Maximum number of PPD files in directory
+                                segment                                     */
+
+#define  INPBINS       16    /* Max no of input bins                        */
+#define  OUTBINS       3     /* Max no of output bins                       */
+#define  PRBUFSZ       4096
+#define  MAX_PSIZE     64
+#define  APPKEYSIZE    20
+#define  MAX_KEYAPPSIZE 78   /* Max size for application name in ini        */
+
+#define  DEF_IEXT      ".ppd"
+#define  DEF_OEXT      ".ppb"
+#define  PB            CHAR *
+#define  MAX_CHARS_IN_EXTENSION 3
+#define  MAX_CHARS_IN_FILENAME 8
+
+//#define MEDIATYPE_STRING    "MediaType"
+
+/*****************************************************************************/
+/*
+** V3.0UI
+*/
+/*
+** A UI entry is each entry within a *OpenUI / *CloseUI.
+*/
+typedef struct _UI_ENTRY
+{
+  USHORT ofsOption;                  // Option string offset
+  USHORT ofsTransString;             // Translation string offset
+  USHORT ofsValue;                   // Value string offset
+} UI_ENTRY, *PUI_ENTRY;
+
+
+/*
+** A UI block is defined here as all data that falls within an
+** *OpenUI / *CloseUI.
+*/
+typedef struct _UI_BLOCK
+{
+  USHORT   ofsUIName;                // Offset to block name
+  USHORT   ofsUITransString;         // Offset to block translation string
+  USHORT   usOrderDep;               // Numeric value, order of block in list
+  USHORT   usDisplayOrder;           // Order block is displayed in listbox
+
+  USHORT   usUILocation;             // Job location where block is written
+    #define UI_ORDER_ANYSETUP     0
+    #define UI_ORDER_JCLSETUP     1
+    #define UI_ORDER_PAGESETUP    2
+    #define UI_ORDER_DOCSETUP     4
+    #define UI_ORDER_PROLOGSETUP  8
+    #define UI_ORDER_EXITSERVER   0x10
+
+  USHORT   usSelectType;             // Selection type for Job Properties
+    #define UI_SELECT_BOOLEAN    4
+    #define UI_SELECT_PICKMANY   2
+    #define UI_SELECT_PICKONE    1
+
+  UCHAR    ucGroupType;
+    #define UIGT_DEFAULTOPTION     0 // Displayed in Job Properties
+    #define UIGT_INSTALLABLEOPTION 1 // Displayed in Printer Properties
+
+  UCHAR    ucPanelID;                // Identifies owner of feature
+    #define UIP_OS2_FEATURE      0   // Feature supported by IBM's J.P. Dialog
+    #define UIP_OEM_FEATURE      1   // Feature supported by OEM Dialog
+    #define UIP_PREDEF_FEATURE   2   // Feature predefined in PPD
+
+  USHORT   usDefaultEntry;           // 0-based offset of default entry (below)
+  USHORT   usNumOfEntries;           // Number of entries in block
+  UI_ENTRY uiEntry[ 1 ];             // List of UI entries
+} UI_BLOCK, *PUI_BLOCK;
+
+/*
+** p is a pointer to the current UI_BLOCK structure.
+*/
+#define QUERY_BLOCK_SIZE( p )       (sizeof( UI_BLOCK ) + \
+                                     (((p)->usNumOfEntries - 1) * \
+                                     sizeof( UI_ENTRY )))
+#define INCREMENT_BLOCK_PTR( p )    p = (PUI_BLOCK) ((PCHAR) p + \
+                                                     QUERY_BLOCK_SIZE( p ))
+
+
+/*
+** The UI list makes up of all *OpenUI / *CloseUI blocks in the PPD.  This
+** contains a header an a pointer to the list buffer.
+*/
+typedef struct _UI_LIST
+{
+  USHORT    usNumOfBlocks;            // Number of total blocks
+  USHORT    usBlockListSize;          // Byte size of UI list
+  PUI_BLOCK pBlockList;               // Pointer to UI list buffer
+
+} UI_LIST, *PUI_LIST;
+
+typedef ULONG   UI_SEL;
+typedef UI_SEL *PUI_SEL;
+
+/*
+** This structure deals with the user-selected UI's.  There is a buffer called
+** the UI selection buffer.  Each 32-bit value in the list is reserved for
+** a UI block and each bit in each 32-bit value represents a UI entry.  If
+** the bit is set to 1, that UI entry is to be sent out with the job.  It is
+** possible to have multiple entry selections per block.
+** This structure contains the byte length of the UI selection block and a
+** pointer to the UI selecton block.
+*/
+typedef struct _UI_SELLIST
+{
+  USHORT  usCurrUIListSize;        // Total byte size of UI selection list
+  USHORT  ofsSelectList;           // Offset to UI selection list
+} UI_SELLIST, *PUI_SELLIST;
+#define ASSIGN_UISELLIST_PTR( p )   (PUI_SEL) ((PBYTE) (p) + sizeof( CNFDATA ))
+
+/*
+** The User Interface Constraints provide a set of mutually exclusive options.
+** This has been provided so that printers can indicate if any options will
+** not work with other options.  For example, a duplex may not support
+** envelopes, so the UI constraints will indicate that if either any envelope
+** or the duplex is selected, then the other cannot be selected.
+** The Entry structure is used for each key.
+** The Block structure contains the ID bitmasks of both keys that are not to
+** be selected together.
+** The list structure contains a variable list of the UIC_BLOCK structures.
+*/
+typedef struct _UIC_ENTRY
+{
+  USHORT ofsUIBlock;       // Index number of keyword in uiEntry[] array
+  UI_SEL bOption;          // Bit values of option(s) for this keyword
+} UIC_ENTRY, *PUIC_ENTRY;
+
+typedef struct _UIC_BLOCK
+{
+  UIC_ENTRY uicEntry1;      // Mutually exclusive key 1
+  UIC_ENTRY uicEntry2;      // Mutually exclusive key 2
+} UIC_BLOCK, *PUIC_BLOCK;
+
+typedef struct _UIC_LIST
+{
+  USHORT     usNumOfUICs;    // Number of UIC_BLOCKs
+  PUIC_BLOCK puicBlockList;  // Variable-length list of UIC_BLOCKs
+} UIC_LIST, *PUIC_LIST;
+
+/*
+** The following macro calculates the size of the UI_LIST structure, including
+** the list of UIC_BLOCKs, in bytes.
+** Argument u is a PUIC_LIST pointer.
+*/
+#define UIC_LIST_SIZE( u )   (sizeof( UIC_LIST ) + (sizeof( UIC_BLOCK ) * \
+                              ((PUIC_LIST) (u)->usNumOfUICs - 1)))
+/*****************************************************************************/
+
+/*
+**  defines for the duplex options
+*/
+
+#define  DUPLEX_NONE   -1
+#define  DUPLEX_FALSE  0
+#define  DUPLEX_DUPLEXNOTUMBLE 1
+#define  DUPLEX_DUPLEXTUMBLE 2
+
+
+
+/*** RESLIST is a structure that points to a variable array of RESTYPE
+** structures.
+** uNumOfRes - Number of RESTYPE structures in pResType.
+** uResOffset - This contains a zero-based offset where the resolution
+** information is kept in a variable-length buffer.  The information
+** for the resolution is kept the following way (in order):
+** 2-byte resolution value, in dots-per-inch
+** ------------------------------------------
+** 1-byte length of the following string:
+** ------------------------------------------
+** string length, this string does not always
+** have a terminating NULL character
+**
+** PRESLIST - Pointer to a RESLIST structure.
+*/
+/*
+** Add a flag to indicate if this resolution is used as part of the JCL
+** format.  If TRUE, the resoluion is part of JCL.  False otherwise.
+*/
+typedef struct _RESLIST
+{
+    SHORT uNumOfRes;
+    SHORT uResOffset;
+    BOOL  bIsJCLResolution;
+} RESLIST;
+typedef RESLIST *PRESLIST;
+
+typedef struct _PPD1
+{
+#if PSDRIVER == 1
+  USHORT iSizeBuffer;        /* size of the buffer where parameters are     */
+                             /* stored (pointed to by DESPPD.pPSStringBuff) */
+#else
+  SHORT iSizeBuffer;         /* size of the buffer where parameters are     */
+                             /* stored (pointed to by DESPPD.pPSStringBuff) */
+#endif
+  SHORT ofsPswrd;            /* offset pointer to password                  */
+  SHORT iPpm;                /* no. of pages printed/minute                 */
+  LONG lFreeVM;              /* amount of free virtual memory               */
+  SHORT ofsPrType;           /* offset pointer to printer type              */
+  SHORT ofsPrName;           /* offset pointer to printer name              */
+  SHORT iResDpi;             /* Resolution in dots per inch                 */
+
+  /*
+  **  Structure containing the available PostScript resolutions.
+  **  (THIS DOES NOT APPEAR TO BE USED ANYMORE.  Resolutions are stored as
+  **  UI items these days.  --ALT)
+  */
+  RESLIST ResList;
+
+  LONG lScrFreq;             /* halftone screen frequency (in cells per     */
+                             /* inch, multiplied by 100)                    */
+  SHORT fIsColorDevice;      /* whether device supports colour or not       */
+  SHORT fIsFileSystem;       /* whether device supports internal DASD       */
+  SHORT ofsReset;            /* offset to printer Reset command string      */
+  SHORT ofsExitserver;       /* offset to ExitServer command string         */
+  LONG iScreenAngle;         /* Halftone screen angle                       */
+  USHORT usLanguageLevel;    /* PostScript language level supported         */
+  SHORT ofsTransferNor;      /* offset to Normalized Transfer function      */
+  SHORT ofsTransferInv;      /* offset to Normalized Inverse Transfer func. */
+  SHORT ofsInitString;       /* offset to PS mode emul. init. string        */
+  SHORT ofsJCLToPS;          /* offset to the JCL to PS interpreter command */
+  SHORT ofsTermString;       /* offset to PS mode emul. terminate string    */
+  SHORT sDefaultDuplex;      /* default duplex mode                         */
+
+  // NOT USED.  Duplex options are defined as UI items.  --ALT
+  SHORT ofsDuplexFalse;      /* string to turn off duplex/tumble            */
+  SHORT ofsDuplexNoTumble;   /* string to turn on duplex                    */
+  SHORT ofsDuplexTumble;     /* string to turn on duplex/tumble             */
+  // NOT USED.
+
+  SHORT ofsPCFileName;       /* offset to recommended 8.3 filename of PPD   */
+
+#if PSDRIVER == 1
+  SHORT fTTSupport;          /* printer has TrueType support -- PSPRINT     */
+#endif
+
+} PPD1;
+
+/*
+** This structure was modified by IBM at some point after 30.800 (post-DDK).
+** To build with compatibility for the very last IBM PSCRIPT releases, define
+** PSDRIVER to 3 or higher.
+*/
+typedef struct _PPD2
+{
+#if PSDRIVER < 3
+  SHORT ofsDfpgsz;           /* offset pointer to default paper size        */
+                             /* (NO LONGER USED NOWADAYS)                   */
+#endif
+
+  SHORT fIsVariablePaper;    /* true if variable paper supported            */
+
+#if PSDRIVER < 3
+  SHORT ofsDefimagearea;     /* offset to paper name string (NO LONGER USED)*/
+  SHORT ofsDefpaperdim;      /* offset to paper dim string (NO LONGER USED) */
+  SHORT iCmpgpairs;          /* no of paper command pairs (NO LONGER USED)  */
+  SHORT ofsLspgCmnds;        /* offset pointer to list of paper commands    */
+                             /* (NO LONGER USED)                            */
+#endif
+
+  SHORT iDmpgpairs;          /* no of paper dimension pairs                 */
+  SHORT ofsDimxyPgsz;        /* offset pointer to list of xy dimensions     */
+  SHORT iImgpgpairs;         /* no of paper imageable coordinate pairs      */
+  /*
+  **  offset pointer to list of Imageable page and coordinates pairs
+  */
+  SHORT ofsImgblPgsz;
+  SHORT ofsCustomPageSize        ;  /* Custom Paper Support */
+  SHORT iCustomPageSizeMinWidth  ;
+  SHORT iCustomPageSizeMaxWidth  ;
+  SHORT iCustomPageSizeMinHeight ;
+  SHORT iCustomPageSizeMaxHeight ;
+
+#if PSDRIVER > 2
+// Four mystery bytes added by IBM post-30.800
+  SHORT sReserved1;
+  SHORT sReserved2;
+#endif
+} PPD2;
+
+
+/*
+** Basically nothing in the PPD3 structure appears to be used at all these
+** days.  All of these values should always be 0.  --ALT
+*/
+typedef struct _PPD3
+{
+  SHORT iManualfeed;         /* default manual feed true=1,false=0,none=-1  */
+  SHORT ofsManualtrue;       /* offset pointer to manual feed true command  */
+  SHORT ofsManualfalse;      /* offset pointer to manual feed false command */
+  SHORT ofsDefinputslot;     /* offset pointer to default input bin         */
+  SHORT iInpbinpairs;        /* no of bin name and command pairs            */
+  SHORT ofsCmInpbins;        /* offset pointer to list of bin names &       */
+                             /* select commands                             */
+  SHORT iNumOfPageSizes;     /* number of page sizes in list                */
+  SHORT ofsPageSizes;        /* list of paper sizes                         */
+} PPD3;
+
+typedef struct _PPD4
+{
+  /*
+  **  Default output order can be normal or reverse
+  */
+  SHORT fIsDefoutorder;
+  /*
+  **  offset pointer to command string for output order normal
+  */
+  SHORT ofsOrdernormal;
+  /*
+  **  offset pointer to command string for output order reverse
+  */
+  SHORT ofsOrderreverse;
+  /*
+  **  offset pointer to name of default output order
+  */
+  SHORT ofsDefoutputbin;
+  /*
+  **  no of bin name and command pairs
+  */
+  SHORT iOutbinpairs;
+  /*
+  **  offset pointer to list of bin select commands
+  */
+  SHORT ofsCmOutbins;
+} PPD4;
+
+typedef struct _PPD5
+{
+  SHORT ofsDeffont;          /* offset pointer to default font name         */
+  SHORT iFonts;              /* no of fonts supported                       */
+  SHORT ofsFontnames;        /* offset pointer to list of font names        */
+} PPD5;
+
+typedef struct _PPD6
+{
+  USHORT usFormCount;        /* Count of forms                              */
+  SHORT  ofsFormTable;       /* Forms Table                                 */
+  SHORT  ofsFormIndex;       /* Index Table                                 */
+} PPD6;
+
+
+/*
+** This is the master data structure that represents the contents of a
+** printer entry inside the PAK file.
+**
+** When reading data from the PAK file, the first [sizeof(DESPPD)] bytes
+** (starting at the main offset for the printer being examined) can be read
+** directly into this structure.
+**
+** This is followed immediately by a variable-length data block containing
+** the contents of the UI_LIST.pBlockList array.  This in turn is followed
+** immediately by a variable-length data block containing the contents of the
+** UIC_LIST.puicBlockList array.  (For both of these, you can determine the
+** array length from the other fields in the aforementioned data structures.)
+**
+** Collectively, the above is referred to as the "descriptor segment".  This
+** is followed by the free-form data buffer pointed to by pPSStringBuff (which
+** has the length indicated in PPD1.iSizeBuffer); this is sometimes referred
+** to as the "information segment".  The various "ofs*" fields (with one or
+** two documented exceptions) in the various child structures point to offsets
+** within this buffer.  (The values pointed to are null-terminated.)
+*/
+typedef struct _DESPPD
+{
+  PPD1 desItems;             /* Individual items defined                    */
+  PPD2 desPage;              /* Storage for paper descriptors defined       */
+  PPD3 desInpbins;           /* Storage for Input bin descriptors defined   */
+  PPD4 desOutbins;           /* Storage for Output bin descriptors defined  */
+  PPD5 desFonts;             /* Storage for Font names defined              */
+  PPD6 desForms;             /* Form tables                                 */
+
+  /*
+  ** Array of UI items (see UI_LIST structure for details).
+  */
+  UI_LIST stUIList;
+
+  /*
+  ** Array of UI constraints (see UIC_LIST for details).
+  */
+  UIC_LIST stUICList;
+
+  PBYTE   pPSStringBuff;
+} DESPPD, *PDESPPD;
+
+
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pin/struct.h src\osdd\pscript\psprint/pin/struct.h
--- src\osdd\pscript\post32/pin/struct.h	Tue Nov 11 18:12:56 2003
+++ src\osdd\pscript\psprint/pin/struct.h	Fri Dec  5 20:48:02 2014
@@ -295,6 +295,8 @@
   SHORT ofsDuplexNoTumble;   /* string to turn on duplex                    */
   SHORT ofsDuplexTumble;     /* string to turn on duplex/tumble             */
   SHORT ofsPCFileName;                                 
+
+  SHORT fTTSupport;          /* printer has TrueType support -- ALT_CUPS    */
 } PPD1;
 
 typedef struct _PPD2
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pkgps.cmd src\osdd\pscript\psprint/pkgps.cmd
--- src\osdd\pscript\post32/pkgps.cmd	Fri Nov 16 17:45:32 2001
+++ src\osdd\pscript\psprint/pkgps.cmd	Sat Aug 31 15:20:36 2013
@@ -10,6 +10,7 @@
 /* Date:    Change:                                 Dev.    Tag:      DCR/PTR */
 /* 6/01/95  created this program                    rakesh                    */
 /* 3/30/01  changes for ppd importing               valters                   */
+/* 11/21/10 increment required ppd version          alt     CUPS42            */
 /******************************************************************************/
 
 
@@ -27,7 +28,7 @@
 
 
   rdrvfiles = basename'.DRV,'basename'.HLP'
-  odrvfiles = basename'.SYM,PSHLP.SYM,*.PFA,*.PFM,PIN.EXE,PPDENC.EXE,PIN.SYM,PPDENC.SYM'
+  odrvfiles = basename'.SYM,PSHLP.SYM,*.PFA,*.PFM,PIN.EXE,PPDENC.EXE,PIN.SYM,PPDENC.SYM,AUXPRINT.PAK'
   vendor    = basename
   devnames  = GetPscriptDevNames( ppbfile )
 
@@ -38,7 +39,7 @@
   rc=SysPutEA(drvname,".VERSION",           EAFormat( version   ) )
   rc=SysPutEA(drvname,".EXPAND",            EAFormat( devnames  ) )
   rc=SysPutEA(drvname,".EXPANDHARDWIRED",   EAFormat( devnames  ) )
-  rc=SysPutEA(drvname,".PPDIMPORTING",      EAFormat( "V1.0.0" ) )
+  rc=SysPutEA(drvname,".PPDIMPORTING",      EAFormat( "V1.2.0" ) )
   rc=SysSetIcon(drvname,"LASER.ICO")
 
 return 0
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/pkgps2.cmd src\osdd\pscript\psprint/pkgps2.cmd
--- src\osdd\pscript\post32/pkgps2.cmd	Mon Jul  9 14:46:30 2001
+++ src\osdd\pscript\psprint/pkgps2.cmd	Tue Nov 23 18:28:46 2010
@@ -19,7 +19,7 @@
   rc=SysGetEA(drvname,".EXPAND", devnames )
   
                                                           /* generate prdesc */
-  rc = GenDrvDevLst(strip(drvdevlst),drvname, substr(devnames,4) )
+  rc = GenDrvDevLst(strip(drvdevlst),drvname, substr(devnames,5) )
 
 return 0
 
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/ppd/ppd2bin.h src\osdd\pscript\psprint/ppd/ppd2bin.h
--- src\osdd\pscript\post32/ppd/ppd2bin.h	Tue Nov 11 18:12:56 2003
+++ src\osdd\pscript\psprint/ppd/ppd2bin.h	Tue Nov 30 11:47:44 2010
@@ -9,13 +9,20 @@
 /*    Source Kit for OS/2. This Copyright statement may not be removed.      */
 /*                                                                           */
 /*****************************************************************************/
-/**************************************************************************
+/****************************************************************************/
+/*                                                                          */
+/*                                                                          */
+/*                                                                          */
+/*                                                                          */
+/*                                                                          */
+/****************************************************************************/
+
+ /**************************************************************************
  *
  * SOURCE FILE NAME = PPD2BIN.H
  *
  * DESCRIPTIVE NAME = Header file for PPD2BIN.H
  *
- *
  * VERSION = V2.0
  *
  * DATE      08/12/91
@@ -104,6 +111,9 @@
   CloseGroup,
   UIConstraints,
   JCLOpenUI,
+  CustomPageSize,
+  ParamCustomPageSize,
+  TTRasterizer,         /* TTRasterizer  --  ALT_CUPS */
   maximum
 } ;
 
@@ -168,7 +178,10 @@
   "*OpenGroup",
   "*CloseGroup",
   "*UIConstraints",
-  "*JCLOpenUI"
+  "*JCLOpenUI",
+  "*CustomPageSize",
+  "*ParamCustomPageSize",
+  "*TTRasterizer"               /* ALT_CUPS */
 } ;
 
 /*
@@ -232,9 +245,11 @@
 
 /*** Predefined Medias in Kyoceras printers
 */
-#define MAX_PREDEF_MEDIA 15
+/*
+#define MAX_PREDEF_MEDIA 28                       //HP5500, HP46005
 char *szPredefMedia[ MAX_PREDEF_MEDIA ]=
 {
+  "None",                                         //HP5500, HP4600
   "Plain",
   "Transparency",
   "Labels",
@@ -249,9 +264,9 @@
   "Vellum",
   "User",
   "Duplex",
-  "CoatedPaper"
+  "CoatedPaper",
 };
-
+*/
 /*
 ** Add 'err_maxPPDs' to verify that the number of PPD's in the
 ** list does not exceed the maximum limit of the compiler.
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/ppdlg.c src\osdd\pscript\psprint/ppdlg.c
--- src\osdd\pscript\post32/ppdlg.c	Tue Nov 11 18:10:24 2003
+++ src\osdd\pscript\psprint/ppdlg.c	Mon Aug 19 10:34:16 2013
@@ -246,7 +246,8 @@
 {
 // driver-global default URL's. Can be overriden by defining device-specific
 // urls in ExtraDV (devlst.c)
-#define DEFAULT_HOME_URL "http://service.software.ibm.com/os2ddpak/html/printers/index.htm"
+//#define DEFAULT_HOME_URL "http://service.software.ibm.com/os2ddpak/html/printers/index.htm"
+#define DEFAULT_HOME_URL "http://www.altsan.org/os2/printing/index.html"
 #define DEFAULT_DRIVER_URL "ftp://service.boulder.ibm.com/ps/products/os2/printpak/"
 
    PVOID   pWebPageCB;
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/utlchnl.c src\osdd\pscript\psprint/utlchnl.c
--- src\osdd\pscript\post32/utlchnl.c	Tue Nov 11 18:10:38 2003
+++ src\osdd\pscript\psprint/utlchnl.c	Thu Sep 16 21:46:36 2010
@@ -2037,7 +2037,9 @@
 
 
 // 172997 - Ensures that raw file line length is within DSC_LINE_LENGTH.
-#define DSC_LINE_LENGTH     255
+// ALT_CUPS
+#define DSC_LINE_LENGTH     254
+// ALT_CUPS
 LONG WriteDSCLengthLine( PDDC  pddc,
                          PBYTE pOutData,
                          ULONG ulDataLen,
diff -burP -X src\osdd\pscript\exclude.lst src\osdd\pscript\post32/utlps.c src\osdd\pscript\psprint/utlps.c
--- src\osdd\pscript\post32/utlps.c	Tue Nov 11 18:10:44 2003
+++ src\osdd\pscript\psprint/utlps.c	Sun Aug 11 23:57:36 2013
@@ -366,13 +366,22 @@
   NULL
 };
 
+#if 0
 static PSZ apszHeaderEnd[] =
 {
   "%%EndProcSet",
   "%%EndProlog",
   NULL
 };
-
+#else
+//PS 20080713
+static PSZ apszHeaderEnd[] =
+{
+  "%%EndSetup",
+  "%%EndProlog",
+  NULL
+};
+#endif
 /* DBCS enabling end   */                                              //@DBCS2
 
 static PSZ apszHeader2[] =
@@ -973,6 +982,8 @@
     ProcessRawResources( pddc );
 
   } /* end if */
+// Paul Smedley 2009-03-22
+  PrintChannel( pddc, (PSZ)"%%%%Pages: %d\n", pdv->shPageno);
 
   if (pddc->fHeaderSent)
   {
@@ -1789,6 +1800,7 @@
   {
     if ( fFirst )
     {
+#if 0 // Paul Smedley 20090322
       /*
       ** There are certain print job specific commands that
       ** should not be generated for encapsulated PostScript
@@ -1797,7 +1809,6 @@
       PrintChannel( pddc, (PSZ) "%%%%DocumentProcSets: PM_1.2\n" );
       PrintChannel( pddc, (PSZ) "%%%%DocumentSuppliedProcSets: PM_1.2\n" );
 
-      
 //      if (pdv->iDestnType == SYSTEM )
       if (pdv->pCNFData->iDestnType == SYSTEM )
       {
@@ -1825,9 +1836,16 @@
         PrintChannel( pddc, (PSZ) "%%%%PrinterName: %ls\n",
                       (PSZ)pdv->dop.pszLogAddress );
       }
+#endif
 
+      //Paul Smedley 2009-03-19
+      PrintChannel( pddc, (PSZ) "%%%%Pages: (atend)\n" );
       
+#if 0 //Paul Smedley 2009-03-19
       PrintChannel( pddc, (PSZ) "%%%%PrinterRect: %ld %ld %ld %ld\n",
+#else
+      PrintChannel( pddc, (PSZ) "%%%%BoundingBox: %ld %ld %ld %ld\n",
+#endif
                     pdv->canvas.rcl.xLeft * 72 /pdv->canvas.Res.x,
                     pdv->canvas.rcl.yBottom * 72 /pdv->canvas.Res.y,
                     pdv->canvas.rcl.xRight * 72 /pdv->canvas.Res.x,
@@ -1849,9 +1867,15 @@
 
     if ( fFirst )
     {
+#if 0
       PrintChannel( pddc, (PSZ) "%%%%BeginProcSet: PM_1.2\n" );
       PrintChannel( pddc, (PSZ) "%% Copyright (c) 1989, 1990 IBM Corporation\n" );
       PrintChannel( pddc, (PSZ) "%% Copyright (c) 1989, 1990 Microsoft Corporation\n" );
+#else
+//PS 20080713
+      PrintChannel( pddc, (PSZ) "%%%%BeginSetup\n" );
+#endif
+// ALT 20130811
       PrintChannel( pddc, (PSZ) "/mDef matrix currentmatrix def\n" );
     }
 
@@ -2497,10 +2521,8 @@
     GplBookletResetOutput( pddc->pdv->hThread );            
   }
   
-
   PrintChannel( pddc, (PSZ) "%%%%Page: 1 1\n" );
 
-  
   if ((pddc->pdv->pCNFData->gjfncb.ulFlags & GNDF_BOOKLETENABLED ) &&  
       GplBookletEnabled( pddc->pdv->hThread ))
   {
@@ -5042,7 +5064,12 @@
                                       pdesPPD->pPSStringBuff,
                                       aKeyname, NULL );
 
-    if (pUIBlock != NULL && pUIBlock->usUILocation == usUILocation)
+    if (pUIBlock != NULL &&
+        ((pUIBlock->usUILocation == usUILocation) ||
+         (( pUIBlock->usUILocation == UI_ORDER_ANYSETUP) &&
+          (usUILocation == UI_ORDER_DOCSETUP))
+         )
+        )
     {
       pBlockName = pUIBlock->ofsUIName + pdesPPD->pPSStringBuff;
 
@@ -5070,7 +5097,12 @@
                 {
                   pKeyString = (PSZ) (pdesPPD->pPSStringBuff + pUIBlock->ofsUIName );
                   PrintChannel( pddc, (PSZ) "[{\n");
+#if 0
                   PrintChannel( pddc, (PSZ) "%%%%BeginFeature: %s %s (%d %d)\n",pKeyString, "Custom",
+#else
+//PS 20080713
+                  PrintChannel( pddc, (PSZ) "%%%%BeginFeature: *%s %s (%d %d)\n",pKeyString, "Custom",
+#endif
                                                  pCNFData->u.iv.pSourcePaper->shCustomWidth[iTray],
                                                  pCNFData->u.iv.pSourcePaper->shCustomHeight[iTray]);
                       pValCustom = (PSZ) (pdesPPD->pPSStringBuff + pdesPPD->desPage.ofsCustomPageSize);
@@ -5078,7 +5110,11 @@
                                                 pCNFData->u.iv.pSourcePaper->shCustomWidth[iTray] ,
                                                 pCNFData->u.iv.pSourcePaper->shCustomHeight[iTray] );
                       WriteCompressString( pddc, pValCustom, fAddNewLine );
+#if 0
                   PrintChannel (pddc, (PSZ) "%%%%EndFeature: %s\n", pKeyString );
+#else
+                  PrintChannel (pddc, (PSZ) "%%%%EndFeature\n");
+#endif
                   PrintChannel (pddc, (PSZ) "} stopped cleartomark\n");
                 }
             }
@@ -5105,7 +5141,12 @@
                 
                 pKeyString = (PSZ) (pdesPPD->pPSStringBuff +
                                   pUIBlock->ofsUIName );
+#if 0
                 PrintChannel( pddc, (PSZ) "%%%%BeginFeature: %s %s\n",
+#else
+//PS20080713
+                PrintChannel( pddc, (PSZ) "%%%%BeginFeature: *%s %s\n",
+#endif
                             pKeyString, (pdesPPD->pPSStringBuff +
                                          pUIEntry->ofsOption) );
               }
@@ -5126,7 +5167,12 @@
                 ** Output "%%EndFeature" plus the UI block name.
                 */
                 
+#if 0
                 PrintChannel (pddc, (PSZ) "%%%%EndFeature: %s\n", pKeyString );
+#else
+//PS20080713
+                PrintChannel (pddc, (PSZ) "%%%%EndFeature\n" );
+#endif
 
                 /*
                 ** Output "} stopped cleartomark" to mark off the end of the
@@ -6633,8 +6679,12 @@
         ( CHECKFLAG( pdv->ulGenFlags, PRINT_TO_FILE ) == 0 ) &&   
         (pdv->fInitStringSent == FALSE))
     {
-      WriteModeString( pddc, pdv->szInitString, pdv->usInitLength );
       pdv->fInitStringSent = TRUE;
+#if 0
+      PrintChannel( pddc, (PSZ) "%%!PS-Adobe\n" );
+#else
+//Causes problems with PJL header prior to %!PS-Adobe?
+      WriteModeString( pddc, pdv->szInitString, pdv->usInitLength );
       
       /*      ** We need to send JCL2PS command in case of PM_Q_RAW and
       ** there are %!PS-Adobe.. at begining of data
@@ -6648,6 +6698,7 @@
           WriteModeString( pddc, pszStr, strlen( pszStr ) );
         }
       }
+#endif
     }
   }
   return;
